[
    {
        "file_path": "D:\\code_doc_generator\\src\\code_parser.py",
        "name": "get_codebase_path_from_user",
        "type": "function",
        "code": "def get_codebase_path_from_user() -> str | None:\n    \"\"\"\n    Prompts the user to enter the path to their codebase directory.\n    Validates if the path exists and is a directory.\n\n    Returns:\n        str: The validated absolute path to the codebase directory, or None if invalid.\n    \"\"\"\n    while True:\n        codebase_path = input(\"请输入您的代码库的本地目录路径 (例如 D:\\\\projects\\\\my_python_project): \").strip()\n        if not codebase_path:\n            print(\"路径不能为空，请重新输入。\")\n            continue\n\n        # Convert to absolute path and normalize\n        absolute_path = os.path.abspath(codebase_path)\n\n        if not os.path.exists(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不存在。请检查路径是否正确。\")\n        elif not os.path.isdir(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不是一个有效的目录。\")\n        else:\n            print(f\"代码库路径确认为: {absolute_path}\")\n            return absolute_path\n        \n        try_again = input(\"要尝试其他路径吗？(y/n): \").lower()\n        if try_again != 'y':\n            return None",
        "start_line": 6,
        "end_line": 33,
        "class_name": null,
        "explanation": "这个Python函数`get_codebase_path_from_user`的主要功能是**交互式地获取并验证用户输入的代码库目录路径**。以下是关键点说明：\n\n目的：\n- 通过命令行提示用户输入代码库的本地路径\n- 验证路径是否存在且是有效目录\n- 返回规范化后的绝对路径或None（当用户放弃输入时）\n\n输入：\n- 无显式参数，但会通过`input()`函数获取用户键盘输入\n\n输出：\n- 成功时 → 返回有效的绝对路径字符串（如`\"D:\\projects\\my_python_project\"`）\n- 失败/放弃时 → 返回`None`\n\n主要行为：\n1. 进入循环持续询问，直到获得有效路径或用户退出\n2. 每次循环时：\n   - 提示用户输入路径（显示中文提示和示例格式）\n   - 检查输入是否为空（拒绝空输入）\n   - 将路径转换为绝对路径（自动处理相对路径/冗余符号）\n   - 验证路径是否存在且是目录（非文件）\n3. 验证失败时：\n   - 显示具体错误（路径不存在/不是目录）\n   - 询问是否重试，输入非'y'则退出循环返回None\n4. 验证成功时：\n   - 打印确认信息\n   - 返回规范化后的绝对路径\n\n注意：函数使用了`os.path`模块进行路径操作，适合跨平台使用。",
        "docstring": "def get_codebase_path_from_user() -> str | None:\n    \"\"\"Prompt user for a codebase directory path and validate its existence.\n    \n    Continuously prompts the user to input a filesystem path until a valid directory\n    is provided or the user chooses to exit. The path is converted to absolute form\n    and checked for existence and directory status.\n\n    Returns:\n        str | None: Absolute path to the validated codebase directory if successful,\n            None if user cancels or provides invalid path.\n    \n    Notes:\n        - User input is stripped of leading/trailing whitespace\n        - Empty inputs are rejected with an error message\n        - Paths are normalized to absolute form before validation\n        - User can cancel by entering 'n' when prompted to retry\n    \"\"\"\n    while True:\n        codebase_path = input(\"请输入您的代码库的本地目录路径 (例如 D:\\\\projects\\\\my_python_project): \").strip()\n        if not codebase_path:\n            print(\"路径不能为空，请重新输入。\")\n            continue\n\n        # Convert to absolute path and normalize\n        absolute_path = os.path.abspath(codebase_path)\n\n        if not os.path.exists(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不存在。请检查路径是否正确。\")\n        elif not os.path.isdir(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不是一个有效的目录。"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\code_parser.py",
        "name": "find_python_files",
        "type": "function",
        "code": "def find_python_files(codebase_path: str) -> list[str]:\n    \"\"\"\n    Traverses the codebase directory and finds all Python files (.py).\n\n    Args:\n        codebase_path (str): The root directory of the codebase.\n\n    Returns:\n        list[str]: A list of absolute paths to Python files found.\n    \"\"\"\n    python_files = []\n    print(f\"\\n正在扫描 '{codebase_path}' 中的 Python 文件...\")\n    for root, _, files in os.walk(codebase_path):\n        # Skip venv directories\n        if \"venv\" in root.split(os.sep) or \".venv\" in root.split(os.sep):\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                file_path = os.path.join(root, file)\n                python_files.append(file_path)\n                print(f\"  找到: {file_path}\")\n    if not python_files:\n        print(\"未找到任何 Python (.py) 文件。\")\n    return python_files",
        "start_line": 35,
        "end_line": 58,
        "class_name": null,
        "explanation": "这个名为`find_python_files`的Python函数用于在指定代码库目录中查找所有的Python文件（.py文件）。以下是它的详细说明：\n\n目的：\n- 扫描给定目录及其子目录，找出所有Python源文件\n- 自动跳过虚拟环境目录（venv/.venv）\n- 返回找到的所有Python文件的绝对路径列表\n\n输入：\n- `codebase_path`：字符串类型，表示要扫描的代码库根目录路径\n\n输出：\n- 返回一个字符串列表，包含所有找到的Python文件的绝对路径\n\n主要行为：\n1. 初始化一个空列表`python_files`来存储结果\n2. 使用`os.walk`遍历代码库目录及其所有子目录\n3. 跳过任何包含\"venv\"或\".venv\"的目录（Python虚拟环境）\n4. 检查每个文件是否以\".py\"结尾\n5. 对于每个Python文件，将其绝对路径添加到结果列表中并打印找到的信息\n6. 如果没有找到任何Python文件，会打印提示信息\n7. 最后返回找到的所有Python文件路径列表\n\n示例输出：\n- 函数会实时打印扫描进度，如：\"正在扫描 '/path/to/code' 中的 Python 文件...\"\n- 对于每个找到的文件会打印：\"找到: /path/to/code/example.py\"\n- 如果没有找到文件会打印：\"未找到任何 Python (.py) 文件。\"",
        "docstring": "def find_python_files(codebase_path: str) -> list[str]:\n    \"\"\"Scans a codebase directory recursively to find all Python (.py) files.\n\n    The function traverses all subdirectories of the given path, excluding any directories\n    named 'venv' or '.venv'. For each Python file found, its absolute path is collected\n    and returned in a list.\n\n    Args:\n        codebase_path: Root directory path to scan for Python files.\n\n    Returns:\n        List of absolute paths to all Python files found. Returns empty list if none found.\n\n    Note:\n        Progress messages are printed during scanning, including skipped directories\n        and found files.\n    \"\"\"\n    python_files = []\n    print(f\"\\n正在扫描 '{codebase_path}' 中的 Python 文件...\")\n    for root, _, files in os.walk(codebase_path):\n        # Skip venv directories\n        if \"venv\" in root.split(os.sep) or \".venv\" in root.split(os.sep):\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                file_path = os.path.join(root, file)\n                python_files.append(file_path)\n                print(f\"  找到: {file_path}\")\n    if not python_files:\n        print(\"未找到任何 Python (.py) 文件。\")\n    return python_files"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\code_parser.py",
        "name": "extract_code_elements_from_file",
        "type": "function",
        "code": "def extract_code_elements_from_file(file_path: str) -> list[dict]:\n    \"\"\"\n    Parses a single Python file and extracts functions, classes, and methods.\n    Requires Python 3.8+ for ast.get_source_segment for accurate code extraction.\n\n    Args:\n        file_path (str): The absolute path to the Python file.\n\n    Returns:\n        list[dict]: A list of dictionaries, each representing a code element.\n                    Each dictionary contains: 'file_path', 'name', 'type', \n                                           'code', 'start_line', 'end_line', 'class_name'.\n    \"\"\"\n    print(f\"  正在解析文件: {file_path}\")\n    extracted_elements = []\n    try:\n        with open(file_path, 'r', encoding='utf-8') as f:\n            source_code_full = f.read()\n    except Exception as e:\n        print(f\"  [!] 读取文件错误 {file_path}: {e}\")\n        return extracted_elements\n\n    try:\n        tree = ast.parse(source_code_full, filename=file_path)\n    except SyntaxError as e:\n        print(f\"  [!] 文件 {file_path} 中存在语法错误: {e}\")\n        return extracted_elements\n\n    for node in tree.body: # Iterate over top-level nodes in the module\n        current_class_name = None\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            # Top-level function\n            try:\n                element_code = ast.get_source_segment(source_code_full, node)\n                if element_code:\n                    extracted_elements.append({\n                        \"file_path\": file_path,\n                        \"name\": node.name,\n                        \"type\": \"async function\" if isinstance(node, ast.AsyncFunctionDef) else \"function\",\n                        \"code\": element_code,\n                        \"start_line\": node.lineno,\n                        \"end_line\": node.end_lineno,\n                        \"class_name\": None\n                    })\n            except Exception as e:\n                print(f\"  [!] 提取函数 '{node.name}' 代码时出错: {e}\")\n\n        elif isinstance(node, ast.ClassDef):\n            current_class_name = node.name\n            try:\n                class_code_segment = ast.get_source_segment(source_code_full, node)\n                if class_code_segment:\n                     extracted_elements.append({\n                        \"file_path\": file_path,\n                        \"name\": node.name,\n                        \"type\": \"class\",\n                        \"code\": class_code_segment, # Contains the full class code including methods\n                        \"start_line\": node.lineno,\n                        \"end_line\": node.end_lineno,\n                        \"class_name\": None\n                    })\n            except Exception as e:\n                print(f\"  [!] 提取类 '{node.name}' 定义代码时出错: {e}\")\n\n            for method_node in node.body:\n                if isinstance(method_node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    try:\n                        method_code = ast.get_source_segment(source_code_full, method_node)\n                        if method_code:\n                            extracted_elements.append({\n                                \"file_path\": file_path,\n                                \"name\": method_node.name,\n                                \"type\": \"async method\" if isinstance(method_node, ast.AsyncFunctionDef) else \"method\",\n                                \"code\": method_code,\n                                \"start_line\": method_node.lineno,\n                                \"end_line\": method_node.end_lineno,\n                                \"class_name\": current_class_name\n                            })\n                    except Exception as e:\n                        print(f\"  [!] 提取方法 '{method_node.name}' (类 {current_class_name}) 代码时出错: {e}\")\n    \n    if extracted_elements:\n        print(f\"  从 {os.path.basename(file_path)} 提取了 {len(extracted_elements)} 个元素。\")\n    return extracted_elements",
        "start_line": 60,
        "end_line": 143,
        "class_name": null,
        "explanation": "这个Python函数`extract_code_elements_from_file`的主要功能是从指定的Python文件中提取代码元素（函数、类和方法）的结构化信息。以下是详细说明：\n\n### 目的\n解析Python源代码文件，提取其中的函数、类和方法定义，并收集每个元素的元数据信息，便于后续分析或处理。\n\n### 输入\n- `file_path` (字符串): 要解析的Python文件的绝对路径\n\n### 输出\n返回一个字典列表，每个字典包含以下键：\n- `file_path`: 源文件路径\n- `name`: 元素名称\n- `type`: 元素类型（\"function\"/\"async function\"/\"class\"/\"method\"/\"async method\"）\n- `code`: 元素完整源代码\n- `start_line`: 起始行号\n- `end_line`: 结束行号\n- `class_name`: 所属类名（仅方法有此字段）\n\n### 主要行为\n1. **文件读取**：尝试以UTF-8编码读取指定文件内容\n2. **语法解析**：使用Python的`ast`模块解析源代码为抽象语法树(AST)\n3. **元素提取**：\n   - 遍历AST中的顶级节点\n   - 识别函数/异步函数定义，提取元数据\n   - 识别类定义，提取类元数据并递归处理类中的方法\n4. **错误处理**：妥善处理文件读取错误和语法错误\n5. **结果报告**：打印解析状态和提取的元素数量\n\n### 技术特点\n- 使用Python 3.8+的`ast.get_source_segment`精确提取源代码片段\n- 区分同步/异步函数和方法\n- 保留代码元素的完整位置信息（行号范围）\n- 对每个提取操作进行错误捕获，避免单元素失败影响整体解析\n\n这个函数适合用于代码分析工具、文档生成器或静态分析工具的前期处理阶段。",
        "docstring": "def extract_code_elements_from_file(file_path: str) -> list[dict]:\n    \"\"\"Extracts code elements (functions, classes, methods) from a Python source file.\n    \n    Parses the given Python file using AST and extracts structural code elements including:\n    - Top-level functions (both sync and async)\n    - Class definitions\n    - Methods (both sync and async) within classes\n    \n    Each extracted element includes metadata such as source location, containing class (for methods),\n    and the actual source code segment.\n\n    Args:\n        file_path: Absolute path to the Python source file to analyze. Must be UTF-8 encoded.\n\n    Returns:\n        List of dictionaries where each dictionary represents a code element with these keys:\n        - file_path: Source file path (same as input)\n        - name: Name of the element (function/class/method name)\n        - type: Element type ('function', 'async function', 'class', 'method', 'async method')\n        - code: Full source code of the element\n        - start_line: Starting line number in source file\n        - end_line: Ending line number in source file\n        - class_name: Containing class name (for methods) or None (for top-level elements)\n\n    Note:\n        Requires Python 3.8+ for ast.get_source_segment() functionality.\n        Silently handles and skips files with read errors or syntax errors.\n    \"\"\"\n    # [原有"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\deepseek_client.py",
        "name": "initialize_deepseek_client",
        "type": "function",
        "code": "def initialize_deepseek_client():  \n    \"\"\"  \n    初始化并返回DeepSeek API客户端。  \n    \"\"\"  \n    if not DEEPSEEK_API_KEY:  \n        raise ValueError(\"未在环境变量中找到DEEPSEEK_API_KEY。\"  \n                         \"请在.env文件或系统环境中设置。\")  \n\n    try:  \n        client = openai.OpenAI(  \n            api_key=DEEPSEEK_API_KEY,  \n            base_url=DEEPSEEK_BASE_URL  \n        )  \n        print(\"DeepSeek客户端初始化成功。\")  \n        # 可在此处添加简单测试调用（如列出模型，若支持）  \n        # 或低成本API调用来确保连接性。  \n        # 示例：尝试列出模型（实际端点可能不同或不支持）：  \n        # models = client.models.list()  \n        # print(\"可用模型（示例）:\", models.data[0].id if models.data else \"未找到模型\")  \n        return client  \n    except Exception as e:  \n        print(f\"初始化DeepSeek客户端时出错：{e}\")  \n        return None",
        "start_line": 18,
        "end_line": 40,
        "class_name": null,
        "explanation": "这个名为`initialize_deepseek_client`的Python函数的主要功能是初始化并返回一个DeepSeek API客户端对象。以下是详细说明：\n\n目的：\n- 创建一个配置好的DeepSeek API客户端实例，用于后续与DeepSeek API的交互\n\n输入：\n- 无显式参数输入\n- 但依赖两个全局变量：\n  - `DEEPSEEK_API_KEY`：API密钥（必需）\n  - `DEEPSEEK_BASE_URL`：API基础URL\n\n输出：\n- 成功时：返回一个`openai.OpenAI`客户端实例\n- 失败时：返回`None`\n\n主要行为：\n1. 首先检查`DEEPSEEK_API_KEY`是否存在，若不存在则抛出`ValueError`异常\n2. 尝试使用API密钥和基础URL初始化OpenAI客户端\n3. 初始化成功后打印成功消息并返回客户端对象\n4. 如果过程中出现任何异常，打印错误信息并返回`None`\n\n注意事项：\n- 函数包含注释建议可以添加测试API调用来验证连接性（当前被注释掉）\n- 错误处理较为基础，仅打印错误不抛出异常\n- 依赖全局环境变量配置，需要提前设置好\n\n典型使用场景：\n```python\nclient = initialize_deepseek_client()\nif client:\n    # 使用client进行API调用\n```",
        "docstring": "def initialize_deepseek_client():\n    \"\"\"初始化并返回配置好的DeepSeek API客户端实例。\n\n    此函数会验证环境变量中的DEEPSEEK_API_KEY，并使用该密钥及预配置的BASE_URL初始化\n    OpenAI兼容客户端。若初始化失败会返回None并打印错误信息。\n\n    Returns:\n        openai.OpenAI | None: 成功时返回配置好的OpenAI客户端实例，失败时返回None。\n\n    Raises:\n        ValueError: 当环境变量中未找到DEEPSEEK_API_KEY时抛出。\n\n    Note:\n        - 要求环境变量中设置DEEPSEEK_API_KEY和DEEPSEEK_BASE_URL\n        - 包含连接测试注释（可取消注释进行简单API验证）\n        - 实际使用时建议添加重试逻辑或更完善的错误处理\n    \"\"\"\n    if not DEEPSEEK_API_KEY:  \n        raise ValueError(\"未在环境变量中找到DEEPSEEK_API_KEY。\"  \n                         \"请在.env文件或系统环境中设置。\")  \n\n    try:  \n        client = openai.OpenAI(  \n            api_key=DEEPSEEK_API_KEY,  \n            base_url=DEEPSEEK_BASE_URL  \n        )  \n        print(\"DeepSeek客户端初始化成功。\")  \n        return client  \n    except Exception as e:  \n        print(f\"初始化DeepSeek客户端时出错：{e}\")  \n        return None"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "_make_api_call",
        "type": "function",
        "code": "def _make_api_call(client: Any, messages: List[Dict[str, str]], max_tokens: int) -> Optional[str]:\n    \"\"\"\n    调用DeepSeek API的辅助函数\n    \"\"\"\n    try:\n        response = client.chat.completions.create(\n            model=DEEPSEEK_MODEL_NAME,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=TEMPERATURE\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"    [!] API调用错误: {e}\")\n        # 可添加更具体的错误处理（例如处理限流、认证错误等）\n        return None",
        "start_line": 14,
        "end_line": 29,
        "class_name": null,
        "explanation": "这个名为`_make_api_call`的Python函数是一个用于调用DeepSeek API的辅助函数。以下是它的详细说明：\n\n**目的**：\n- 封装与DeepSeek API的交互逻辑，简化API调用过程\n- 处理API调用中可能出现的错误，提供基本的错误处理\n\n**输入参数**：\n1. `client`: 一个API客户端对象，用于实际发起API请求\n2. `messages`: 一个字典列表，包含对话消息（通常包含\"role\"和\"content\"键）\n3. `max_tokens`: 整数，指定API响应中生成的最大token数量\n\n**输出**：\n- 成功时：返回API响应中第一条消息的内容（去除首尾空格）\n- 失败时：打印错误信息并返回`None`\n\n**主要行为**：\n1. 尝试通过客户端调用DeepSeek的聊天补全API\n2. 使用预定义的模型名称(`DEEPSEEK_MODEL_NAME`)和温度参数(`TEMPERATURE`)\n3. 如果调用成功，提取并返回第一条响应消息的内容\n4. 如果调用失败，捕获异常并打印错误信息，然后返回`None`\n\n**备注**：\n- 函数名前的下划线(`_`)通常表示这是模块内部使用的私有函数\n- 当前错误处理较简单，注释建议可以添加更具体的错误处理逻辑\n- 使用了类型注解(如`Any`, `List[Dict[str, str]]`)来提高代码可读性",
        "docstring": "def _make_api_call(client: Any, messages: List[Dict[str, str]], max_tokens: int) -> Optional[str]:\n    \"\"\"调用DeepSeek API并返回生成的文本内容。\n\n    这是一个辅助函数，用于封装DeepSeek API的调用逻辑。它会处理基本的错误情况，\n    并在出现异常时返回None。\n\n    Args:\n        client: DeepSeek API客户端实例，用于发起请求。\n        messages: 包含对话消息的字典列表，每个字典应包含'role'和'content'键。\n        max_tokens: 生成响应允许的最大token数量。\n\n    Returns:\n        成功时返回API生成的文本内容(已去除首尾空格)，失败时返回None。\n\n    Note:\n        当前仅捕获并打印异常，未来可扩展更具体的错误处理逻辑(如限流、认证错误等)。\n    \"\"\"\n    try:\n        response = client.chat.completions.create(\n            model=DEEPSEEK_MODEL_NAME,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=TEMPERATURE\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"    [!] API调用错误: {e}\")\n        # 可添加更具体的错误处理（例如处理限流、认证错误等）\n        return None"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "generate_explanation_for_element",
        "type": "function",
        "code": "def generate_explanation_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"\n    为给定的代码元素生成纯文本解释\n    \"\"\"\n    element_type = code_element['type']\n    element_name = code_element['name']\n    element_code = code_element['code']\n    class_name = code_element.get('class_name')\n\n    prompt_intro = f\"你是一位擅长代码分析和文档编写的专家AI助手。\"\n    \n    user_prompt = f\"解释以下名为'{element_name}'的Python {element_type}\"\n    if class_name:\n        user_prompt += f\"（属于'{class_name}'类）\"\n    user_prompt += f\"的功能。代码如下：\\n\\n```python\\n{element_code}\\n```\\n\\n\"\n    user_prompt += \"请用清晰简洁的语言进行解释。重点说明其目的、输入、输出（如果有）以及主要行为。\"\n\n    messages = [\n        {\"role\": \"system\", \"content\": prompt_intro},\n        {\"role\": \"user\", \"content\": user_prompt}\n    ]\n\n    print(f\"  -> 正在为{element_type} '{element_name}'生成解释...\")\n    explanation = _make_api_call(client, messages, MAX_TOKENS_EXPLANATION)\n    \n    if explanation:\n        print(f\"  <- 已收到'{element_name}'的解释。\")\n    else:\n        print(f\"  <!> 未能为'{element_name}'生成解释。\")\n    return explanation",
        "start_line": 31,
        "end_line": 60,
        "class_name": null,
        "explanation": "这个名为`generate_explanation_for_element`的函数是一个用于为Python代码元素生成纯文本解释的工具。以下是其主要功能说明：\n\n目的：\n- 该函数的主要目的是通过调用AI接口（如OpenAI API）为给定的Python代码元素（如函数、类、方法等）生成自然语言解释。\n\n输入：\n- `client`：一个API客户端对象，用于实际调用AI服务\n- `code_element`：包含代码元素信息的字典，需要包含以下键：\n  - `type`：代码元素类型（如\"function\"、\"class\"等）\n  - `name`：代码元素名称\n  - `code`：代码内容\n  - `class_name`（可选）：如果元素是类方法，则包含所属类名\n\n输出：\n- 返回一个字符串（`Optional[str]`），即生成的代码解释文本\n- 如果生成失败则返回None\n\n主要行为：\n1. 从输入字典中提取代码元素的基本信息（类型、名称、代码等）\n2. 构造一个系统提示（说明AI的角色）和用户提示（包含代码元素的具体信息和请求）\n3. 如果代码元素属于某个类，会在提示中特别说明\n4. 调用`_make_api_call`函数（未显示）实际发送请求到AI服务\n5. 打印生成过程的日志信息\n6. 返回AI生成的解释文本或None（如果失败）\n\n示例使用场景：\n当分析一个Python项目时，可以用这个函数自动为项目中的每个函数/类生成文档说明，帮助开发者或新团队成员快速理解代码功能。\n\n注意：\n- 该函数依赖于外部的`_make_api_call`函数来实际处理API调用\n- 使用了`MAX_TOKENS_EXPLANATION`常量（未显示定义）来控制生成文本的最大长度",
        "docstring": "def generate_explanation_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"Generates a plain text explanation for a given code element using AI assistance.\n\n    This function takes a code element (function, class, method etc.) and constructs a prompt\n    to request an AI-generated explanation of its purpose and behavior. The explanation focuses\n    on the element's functionality, inputs/outputs, and main operations.\n\n    Args:\n        client: An AI client instance capable of processing natural language prompts.\n        code_element: A dictionary containing the code element metadata with keys:\n            - type: The type of code element (e.g. 'function', 'class', 'method')\n            - name: The name of the code element\n            - code: The actual source code of the element\n            - class_name: Optional name of the containing class (for methods)\n\n    Returns:\n        A string containing the generated explanation, or None if the request failed.\n\n    Note:\n        The function prints status messages during generation and handles API call failures."
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "generate_docstring_for_element",
        "type": "function",
        "code": "def generate_docstring_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"\n    为给定的代码元素生成Google风格的文档字符串\n    \"\"\"\n    element_type = code_element['type']\n    element_name = code_element['name']\n    element_code = code_element['code']\n    class_name = code_element.get('class_name')\n\n    prompt_intro = f\"你是一位擅长生成高质量代码文档的专家AI助手。\"\n    \n    user_prompt = f\"为以下名为'{element_name}'的Python {element_type}\"\n    if class_name:\n        user_prompt += f\"（来自'{class_name}'类）\"\n    user_prompt += f\"生成简洁的Google风格文档字符串。代码如下：\\n\\n```python\\n{element_code}\\n```\\n\\n\"\n    user_prompt += \"文档字符串应准确描述其用途、参数（如果有，包括可推断的类型）、\"\n    user_prompt += \"以及返回值（如果有，包括可推断的类型）。对于类，提供简要概述，\"\n    user_prompt += \"并在概述中提及关键属性或方法（如适用）。不要在文档字符串主体中包含函数/方法/类签名，只包含描述性文本。\"\n    user_prompt += \"确保文档字符串以简短的摘要行开头，后跟空行，然后根据需要添加更详细的说明。正确格式化以符合Python规范。\"\n\n    messages = [\n        {\"role\": \"system\", \"content\": prompt_intro},\n        {\"role\": \"user\", \"content\": user_prompt}\n    ]\n\n    print(f\"  -> 正在为{element_type} '{element_name}'生成文档字符串...\")\n    docstring = _make_api_call(client, messages, MAX_TOKENS_DOCSTRING)\n    \n    if docstring:\n        # 清理LLM可能生成的多余markdown ```python ``` 代码块标记\n        if docstring.startswith(\"```python\\n\"):\n            docstring = docstring.replace(\"```python\\n\", \"\", 1)\n            if docstring.endswith(\"\\n```\"):\n                docstring = docstring[:-len(\"\\n```\")]\n        if docstring.startswith(\"```\"):  # 通用的 ```\n            docstring = docstring.replace(\"```\", \"\", 1)\n            if docstring.endswith(\"```\"):\n                docstring = docstring[:-len(\"```\")]\n\n        # 移除LLM可能生成的多余的开头/结尾三引号\n        docstring = docstring.strip().strip('\"\"\"').strip(\"'''\").strip()\n        print(f\"  <- 已收到'{element_name}'的文档字符串。\")\n    else:\n        print(f\"  <!> 未能为'{element_name}'生成文档字符串。\")\n    return docstring",
        "start_line": 62,
        "end_line": 106,
        "class_name": null,
        "explanation": "这个函数`generate_docstring_for_element`的主要目的是为给定的Python代码元素自动生成符合Google风格规范的文档字符串(docstring)。\n\n**输入:**\n- `client`: 一个API客户端对象，用于与AI服务交互\n- `code_element`: 包含代码元素信息的字典，包括:\n  - `type`: 代码元素类型(如函数、类等)\n  - `name`: 元素名称\n  - `code`: 元素的实际代码\n  - `class_name`(可选): 如果元素属于某个类，包含类名\n\n**输出:**\n- 返回生成的文档字符串(字符串)，如果生成失败则返回None\n\n**主要行为:**\n1. 从输入字典中提取代码元素信息(类型、名称、代码等)\n2. 构造一个详细的提示(prompt)，要求AI生成Google风格的文档字符串\n3. 通过API客户端(`_make_api_call`)向AI服务发送请求\n4. 对返回的文档字符串进行清理:\n   - 移除可能多余的代码块标记(```python)\n   - 移除多余的三引号\n5. 打印生成过程的日志信息\n6. 返回清理后的文档字符串\n\n**特点:**\n- 支持多种代码元素(函数、类等)\n- 生成的文档字符串符合Google风格规范\n- 包含详细的提示以确保生成质量\n- 有完善的错误处理和日志记录\n- 对AI返回结果进行清理以确保格式正确\n\n这个函数主要用于自动化代码文档生成，可以作为代码文档工具的一部分使用。",
        "docstring": "def generate_docstring_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"为给定的代码元素生成符合Google风格的文档字符串。\n\n    使用AI客户端为Python代码元素（函数/方法/类）生成格式化的文档字符串。处理LLM返回结果，\n    清理多余的格式标记并返回纯净的文档字符串内容。\n\n    Args:\n        client (Any): 用于与AI API交互的客户端对象\n        code_element (Dict[str, Any]): 包含代码元素信息的字典，必须包含:\n            - type: 元素类型（如'function'、'class'等）\n            - name: 元素名称\n            - code: 元素源代码\n            - class_name (可选): 如果元素是方法，所属类名\n\n    Returns:\n        Optional[str]: 生成的文档字符串（已清理格式），若生成失败则返回None\n\n    Note:\n        - 生成的文档字符串会自动移除多余的markdown代码块标记和三引号\n        - 会打印生成过程的日志信息到控制台"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "generate_project_overview",
        "type": "function",
        "code": "def generate_project_overview(client: Any, all_elements: List[Dict[str, Any]], project_name: str = \"本项目\") -> Optional[str]:\n    \"\"\"\n    为README文件生成项目的高层概述\n    \"\"\"\n    if not all_elements:\n        return \"未提供代码元素，无法生成概述。\"\n\n    summaries = []\n    for element in all_elements:\n        if element.get('explanation'):  # 使用之前生成的解释\n            summary = f\"- {element['type'].capitalize()} '{element['name']}': {element['explanation'][:150]}...\"  # 截断以保持简洁\n            if element.get('class_name'):\n                summary = f\"- {element['type'].capitalize()} '{element['name']}' (在'{element['class_name']}'类中): {element['explanation'][:150]}...\"\n            summaries.append(summary)\n        elif element['type'] == 'class':  # 如果没有解释，使用类名\n            summaries.append(f\"- 类 '{element['name']}'\")\n\n    if not summaries:\n        return \"没有可用的解释来生成概述。\"\n\n    prompt_intro = \"你是一个负责为README文件创建项目摘要的AI助手。\"\n    user_prompt = (\n        f\"根据以下来自'{project_name}'的代码元素摘要，\"\n        f\"生成适合项目README文件的简洁、高层概述（2-4段）。\"\n        f\"概述应描述项目的主要目的和可从这些元素推断出的关键功能。\\n\\n\"\n        f\"代码元素摘要:\\n\" + \"\\n\".join(summaries[:20]) +  # 限制输入大小\n        f\"\\n\\n专注于描述项目可能的连贯叙述。\"\n    )\n    \n    messages = [\n        {\"role\": \"system\", \"content\": prompt_intro},\n        {\"role\": \"user\", \"content\": user_prompt}\n    ]\n\n    print(f\"  -> 正在为'{project_name}'生成项目概述...\")\n    overview = _make_api_call(client, messages, max_tokens=600)\n    if overview:\n        print(f\"  <- 已收到项目概述。\")\n    else:\n        print(f\"  <!> 未能生成项目概述。\")\n    return overview",
        "start_line": 108,
        "end_line": 148,
        "class_name": null,
        "explanation": "这个函数`generate_project_overview`的主要目的是为项目的README文件生成一个高层概述。以下是它的关键点：\n\n**目的**：\n- 根据代码元素的摘要信息，自动生成适合项目README文件的简洁概述（2-4段）\n- 描述项目的主要目的和关键功能\n\n**输入**：\n1. `client`: 用于调用API的客户端对象\n2. `all_elements`: 包含代码元素信息的字典列表，每个字典包含：\n   - `type` (元素类型，如\"class\")\n   - `name` (元素名称)\n   - `explanation` (可选，元素的解释文本)\n   - `class_name` (可选，所属类名)\n3. `project_name`: 项目名称（默认为\"本项目\"）\n\n**输出**：\n- 返回生成的概述文本字符串\n- 如果没有可用的输入数据或无法生成概述，则返回相应的错误信息字符串\n\n**主要行为**：\n1. 首先检查输入是否为空，为空则返回错误信息\n2. 遍历所有代码元素，为每个元素生成摘要行：\n   - 如果有解释文本，则截取前150个字符生成摘要\n   - 如果是类元素但没有解释，则只使用类名\n3. 如果没有生成任何摘要，返回错误信息\n4. 构造API调用提示信息，包括：\n   - 系统角色提示\n   - 用户提示（包含项目名和摘要信息）\n5. 调用API生成概述\n6. 打印生成过程的日志信息\n7. 返回生成的概述或None（如果生成失败）\n\n**注意**：\n- 函数会限制输入的摘要数量（最多20个）以避免过长的API请求\n- 生成的概述会专注于项目的整体叙述而非细节\n- 函数依赖于`_make_api_call`这个未显示的辅助函数来实际调用API",
        "docstring": "Generates a high-level project overview for a README file based on code elements.\n\nThis function takes a list of code elements with their explanations and generates a concise,\nwell-structured project overview suitable for a README file. The overview describes the\nproject's main purpose and key functionality inferred from the provided code elements.\n\nArgs:\n    client (Any): The API client used to make the generation request.\n    all_elements (List[Dict[str, Any]]): List of code element dictionaries containing:\n        - type: The element type (e.g., 'class', 'function')\n        - name: The element name\n        - explanation: Generated explanation of the element (optional)\n        - class_name: Containing class name if element is a method (optional)\n    project_name (str): The name of the project to reference in the overview. Defaults to \"本项目\".\n\nReturns:\n    Optional[str]: The generated project overview as markdown text, or None if generation fails.\n        Returns specific error messages if:\n        - No elements are provided (\"未提供代码元素，无法生成概述。\")\n        - No usable explanations are available (\"没有可用的解释来生成概述。\")\n\nThe function processes up to 20 code elements to generate the overview, truncating long\nexplanations for conciseness. Class elements without explanations are included by name only.\nThe generated overview typically consists of 2-4 paragraphs describing the project's purpose\nand main functionality."
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "process_elements_for_docs",
        "type": "function",
        "code": "def process_elements_for_docs(client: Any, code_elements: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"\n    遍历代码元素，为每个元素生成解释和文档字符串。\n    通过添加'explanation'和'docstring'键来修改输入的字典列表。\n    \"\"\"\n    print(f\"\\n开始为{len(code_elements)}个元素生成文档...\")\n    for i, element in enumerate(code_elements):\n        print(f\"\\n处理元素 {i+1}/{len(code_elements)}: {element['type']} '{element['name']}' 在 '{element['file_path']}'\")\n        \n        # 过滤掉可能不需要详细解释/文档字符串的元素（例如非常短的元素）\n        # 或基于类型过滤（例如，如果不想为类本身生成文档，只处理其方法）\n        # 目前，我们处理所有函数、方法和类。\n        if element['type'] in ['function', 'method', 'async function', 'async method', 'class']:\n            explanation = generate_explanation_for_element(client, element)\n            element['explanation'] = explanation\n            time.sleep(API_CALL_DELAY_SECONDS)  # 遵守API速率限制\n\n            docstring = generate_docstring_for_element(client, element)\n            element['docstring'] = docstring\n            time.sleep(API_CALL_DELAY_SECONDS)  # 遵守API速率限制\n        else:\n            element['explanation'] = None\n            element['docstring'] = None\n            print(f\"  跳过为元素类型 {element['type']} 生成文档\")\n            \n    return code_elements",
        "start_line": 150,
        "end_line": 175,
        "class_name": null,
        "explanation": "这个函数`process_elements_for_docs`的主要功能是为代码元素生成解释和文档字符串，并返回处理后的结果。以下是详细说明：\n\n**目的**：\n- 为代码元素（如函数、方法、类等）生成自然语言解释和文档字符串\n- 通过添加`explanation`和`docstring`字段来丰富输入的代码元素信息\n\n**输入**：\n- `client`: 一个客户端对象（类型为Any，具体类型未指定）\n- `code_elements`: 包含代码元素信息的字典列表，每个字典包含：\n  - `type`: 元素类型（如'function', 'method', 'class'等）\n  - `name`: 元素名称\n  - `file_path`: 所在文件路径\n\n**输出**：\n- 返回处理后的`code_elements`列表，其中每个元素字典新增了两个键：\n  - `explanation`: 该元素的自然语言解释\n  - `docstring`: 为该元素生成的文档字符串\n\n**主要行为**：\n1. 打印开始处理的日志信息\n2. 遍历所有代码元素：\n   - 打印当前处理进度\n   - 只处理特定类型的元素（函数、方法、异步函数、异步方法、类）\n   - 为这些元素调用`generate_explanation_for_element`生成解释\n   - 调用`generate_docstring_for_element`生成文档字符串\n   - 每次API调用后暂停以避免速率限制\n3. 对于不处理的元素类型，将`explanation`和`docstring`设为None\n4. 返回处理后的完整列表\n\n**注意事项**：\n- 函数会在API调用之间暂停（`API_CALL_DELAY_SECONDS`）\n- 会跳过非目标类型的元素（如变量等）\n- 保留了原始输入的所有信息，只是新增了两个字段",
        "docstring": "def process_elements_for_docs(client: Any, code_elements: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Processes code elements to generate explanations and docstrings for documentation.\n\n    Iterates through a list of code elements (functions, methods, classes) and adds\n    'explanation' and 'docstring' fields to each element's dictionary. Skips elements\n    that don't require documentation (based on type or other criteria).\n\n    Args:\n        client: Client object used to generate explanations and docstrings.\n        code_elements: List of dictionaries representing code elements to process.\n            Each dictionary must contain 'type', 'name', and 'file_path' keys.\n\n    Returns:\n        List[Dict[str, Any]]: The modified input list with added 'explanation' and\n        'docstring' keys for each processed element. Unprocessed elements will have\n        these values set to None.\n\n    Notes:\n        - Processes only elements of type: function, method, async function, async method, or class\n        - Adds rate limiting delays between API calls to comply with usage limits\n        - Prints progress information during processing"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\main.py",
        "name": "sanitize_filename",
        "type": "function",
        "code": "def sanitize_filename(name_part: str) -> str:\n    \"\"\"\n    清理字符串，使其适合作为文件名的一部分。\n    移除或替换不安全/不合适的字符。\n    \"\"\"\n    if not name_part:\n        return \"\"\n    name_part = str(name_part) # 确保是字符串\n    # 替换路径分隔符，移除不期望的字符\n    name_part = name_part.replace(os.path.sep, '_')\n    # 只保留字母数字、空格、点、下划线、中横线\n    valid_chars = \"\".join(c for c in name_part if c.isalnum() or c in (' ', '.', '_', '-')).strip()\n    # 避免文件名过长，并替换空格为下划线\n    return valid_chars[:60].replace(' ', '_')",
        "start_line": 15,
        "end_line": 28,
        "class_name": null,
        "explanation": "这个名为 `sanitize_filename` 的 Python 函数用于清理字符串，使其适合作为文件名的一部分。以下是详细解释：\n\n### 目的\n将任意输入字符串处理成安全、合法的文件名部分，主要功能包括：\n1. 移除可能引发路径问题的字符（如路径分隔符）\n2. 只保留安全的字符集（字母数字和少数特殊字符）\n3. 防止文件名过长\n4. 规范化空格处理\n\n### 输入\n- `name_part: str`：需要被处理的原始字符串（可以是任何类型，但会被转为字符串）\n\n### 输出\n- `str`：处理后的安全字符串，适合作为文件名部分\n\n### 主要行为\n1. **空值处理**：如果输入为空，直接返回空字符串\n2. **类型转换**：确保输入被转为字符串类型\n3. **路径分隔符替换**：将系统路径分隔符（如 `/` 或 `\\`）替换为下划线 `_`\n4. **字符过滤**：只保留以下字符：\n   - 字母数字（`isalnum()`）\n   - 空格、点号（`.`）、下划线（`_`）、中横线（`-`）\n5. **长度限制**：截断字符串至前60个字符\n6. **空格处理**：将所有剩余空格替换为下划线\n\n### 示例\n输入：`\"My Document: 2023/Report.txt\"`  \n处理过程：\n1. 替换 `/` → `_`\n2. 过滤 `:` → 移除\n3. 截断长度（假设无需截断）\n4. 替换空格 → `_`  \n输出：`\"My_Document_2023_Report.txt\"`\n\n### 注意事项\n- 不处理文件系统保留名称（如 `CON`、`NUL` 等）\n- 可能生成空字符串（如果输入不含有效字符）\n- 点号（`.`）被保留，可能在某些系统中表示文件扩展名",
        "docstring": "def sanitize_filename(name_part: str) -> str:\n    \"\"\"Cleans a string to make it suitable as a filename component.\n    \n    Processes the input string by removing or replacing unsafe/inappropriate characters.\n    Converts non-string inputs to strings, replaces path separators with underscores,\n    and removes all characters except alphanumerics, spaces, dots, underscores and hyphens.\n    Also truncates the result to 60 characters and replaces spaces with underscores.\n\n    Args:\n        name_part: Input string to be sanitized. Will be converted to string if not already.\n\n    Returns:\n        Sanitized string safe for use as a filename component. Returns empty string if input\n        is empty. Result is truncated to 60 characters with spaces replaced by underscores.\n    \"\"\"\n    if not name_part:\n        return \"\"\n    name_part = str(name_part) # 确保是字符串\n    # 替换路径分隔符，移除不期望的字符\n    name_part = name_part.replace(os.path.sep, '_')\n    # 只保留字母数字、空格、点、下划线、中横线\n    valid_chars = \"\".join(c for c in name_part if c.isalnum() or c in (' ', '.', '_', '-')).strip()\n    # 避免文件名过长，并替换空格为下划线\n    return valid_chars[:60].replace(' ', '_')"
    }
]