[
    {
        "file_path": "D:\\code_doc_generator\\src\\code_parser.py",
        "name": "get_codebase_path_from_user",
        "type": "function",
        "code": "def get_codebase_path_from_user() -> str | None:\n    \"\"\"\n    Prompts the user to enter the path to their codebase directory.\n    Validates if the path exists and is a directory.\n\n    Returns:\n        str: The validated absolute path to the codebase directory, or None if invalid.\n    \"\"\"\n    while True:\n        codebase_path = input(\"请输入您的代码库的本地目录路径 (例如 D:\\\\projects\\\\my_python_project): \").strip()\n        if not codebase_path:\n            print(\"路径不能为空，请重新输入。\")\n            continue\n\n        # Convert to absolute path and normalize\n        absolute_path = os.path.abspath(codebase_path)\n\n        if not os.path.exists(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不存在。请检查路径是否正确。\")\n        elif not os.path.isdir(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不是一个有效的目录。\")\n        else:\n            print(f\"代码库路径确认为: {absolute_path}\")\n            return absolute_path\n        \n        try_again = input(\"要尝试其他路径吗？(y/n): \").lower()\n        if try_again != 'y':\n            return None",
        "start_line": 6,
        "end_line": 33,
        "class_name": null,
        "explanation": "这个名为`get_codebase_path_from_user`的Python函数的主要功能是**交互式地获取并验证用户输入的代码库目录路径**。以下是详细说明：\n\n### 目的\n- 通过命令行提示用户输入代码库的本地路径\n- 验证路径是否存在且是一个有效目录\n- 返回规范化后的绝对路径或None（当用户放弃输入时）\n\n### 输入\n- 无显式参数（通过`input()`函数获取用户交互式输入）\n\n### 输出\n- 成功时返回：`str`类型（验证通过的绝对路径）\n- 失败时返回：`None`（当用户选择不再重试时）\n\n### 主要行为\n1. **循环提示**：持续要求用户输入路径，直到获得有效路径或用户选择退出\n2. **路径验证**：\n   - 检查输入是否为空\n   - 转换为绝对路径（处理相对路径和路径分隔符）\n   - 检查路径是否存在\n   - 确认路径指向的是目录（而非文件）\n3. **用户交互**：\n   - 显示中文提示信息\n   - 对无效路径给出具体错误说明\n   - 每次验证失败后询问是否重试\n4. **返回结果**：\n   - 验证成功时返回规范化的绝对路径\n   - 用户选择不重试时返回None\n\n### 典型使用场景\n当程序需要用户指定一个本地代码库目录时（如代码分析工具、版本控制系统等），这个函数提供了友好的交互式路径获取方式。",
        "docstring": "def get_codebase_path_from_user() -> str | None:\n    \"\"\"Prompts the user to input and validates a codebase directory path.\n\n    Continuously prompts the user to enter a filesystem path until a valid directory\n    is provided or the user chooses to exit. The path is converted to an absolute\n    path and checked for existence and directory validity.\n\n    Returns:\n        str | None: The absolute path to the validated codebase directory if successful,\n        or None if the user cancels or provides an invalid path.\n    \"\"\"\n    while True:\n        codebase_path = input(\"请输入您的代码库的本地目录路径 (例如 D:\\\\projects\\\\my_python_project): \").strip()\n        if not codebase_path:\n            print(\"路径不能为空，请重新输入。\")\n            continue\n\n        # Convert to absolute path and normalize\n        absolute_path = os.path.abspath(codebase_path)\n\n        if not os.path.exists(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不存在。请检查路径是否正确。\")\n        elif not os.path.isdir(absolute_path):\n            print(f\"错误：路径 '{absolute_path}' 不是一个有效的目录。\")\n        else:\n            print(f\"代码库路径确认为: {absolute_path}\")\n            return absolute_path\n        \n        try_again = input(\"要尝试其他路径吗？(y/n): \").lower()\n        if try_again != 'y"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\code_parser.py",
        "name": "find_python_files",
        "type": "function",
        "code": "def find_python_files(codebase_path: str) -> list[str]:\n    \"\"\"\n    Traverses the codebase directory and finds all Python files (.py).\n\n    Args:\n        codebase_path (str): The root directory of the codebase.\n\n    Returns:\n        list[str]: A list of absolute paths to Python files found.\n    \"\"\"\n    python_files = []\n    print(f\"\\n正在扫描 '{codebase_path}' 中的 Python 文件...\")\n    for root, _, files in os.walk(codebase_path):\n        # Skip venv directories\n        if \"venv\" in root.split(os.sep) or \".venv\" in root.split(os.sep):\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                file_path = os.path.join(root, file)\n                python_files.append(file_path)\n                print(f\"  找到: {file_path}\")\n    if not python_files:\n        print(\"未找到任何 Python (.py) 文件。\")\n    return python_files",
        "start_line": 35,
        "end_line": 58,
        "class_name": null,
        "explanation": "这个名为`find_python_files`的函数用于在指定代码库目录中查找所有的Python文件（.py文件）。以下是详细说明：\n\n目的：\n- 扫描给定的代码库目录及其所有子目录，找出所有的Python源文件\n- 自动跳过虚拟环境目录（venv或.venv）\n\n输入：\n- `codebase_path`：字符串类型，表示要扫描的代码库根目录路径\n\n输出：\n- 返回一个字符串列表，包含所有找到的Python文件的绝对路径\n\n主要行为：\n1. 初始化一个空列表`python_files`来存储结果\n2. 使用`os.walk`遍历代码库目录及其所有子目录\n3. 对于每个目录：\n   - 如果目录路径中包含\"venv\"或\".venv\"（虚拟环境目录），则跳过不处理\n   - 检查目录中的每个文件，如果文件以\".py\"结尾，则将其绝对路径加入结果列表\n4. 在扫描过程中会打印找到的每个Python文件路径\n5. 如果没有找到任何Python文件，会打印提示信息\n6. 最后返回找到的所有Python文件路径列表\n\n示例输出：\n- 如果找到文件，会打印类似\"找到: /path/to/file.py\"的信息\n- 如果没找到文件，会打印\"未找到任何Python (.py) 文件\"\n\n这个函数常用于代码分析、静态检查或自动化测试等场景，需要收集项目中所有Python源文件的情况。",
        "docstring": "def find_python_files(codebase_path: str) -> list[str]:\n    \"\"\"Traverses a directory tree to find all Python (.py) files.\n\n    Scans the specified codebase directory recursively, excluding any virtual environment\n    directories (venv/.venv), and collects all Python files found.\n\n    Args:\n        codebase_path: The root directory path to search for Python files.\n\n    Returns:\n        A list of absolute file paths for all found Python files. Returns empty list if none found.\n\n    Note:\n        Prints progress messages during scanning and reports if no files are found.\n    \"\"\"\n    python_files = []\n    print(f\"\\n正在扫描 '{codebase_path}' 中的 Python 文件...\")\n    for root, _, files in os.walk(codebase_path):\n        # Skip venv directories\n        if \"venv\" in root.split(os.sep) or \".venv\" in root.split(os.sep):\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                file_path = os.path.join(root, file)\n                python_files.append(file_path)\n                print(f\"  找到: {file_path}\")\n    if not python_files:\n        print(\"未找到任何 Python (.py) 文件。\")\n    return python_files"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\code_parser.py",
        "name": "extract_code_elements_from_file",
        "type": "function",
        "code": "def extract_code_elements_from_file(file_path: str) -> list[dict]:\n    \"\"\"\n    Parses a single Python file and extracts functions, classes, and methods.\n    Requires Python 3.8+ for ast.get_source_segment for accurate code extraction.\n\n    Args:\n        file_path (str): The absolute path to the Python file.\n\n    Returns:\n        list[dict]: A list of dictionaries, each representing a code element.\n                    Each dictionary contains: 'file_path', 'name', 'type', \n                                           'code', 'start_line', 'end_line', 'class_name'.\n    \"\"\"\n    print(f\"  正在解析文件: {file_path}\")\n    extracted_elements = []\n    try:\n        with open(file_path, 'r', encoding='utf-8') as f:\n            source_code_full = f.read()\n    except Exception as e:\n        print(f\"  [!] 读取文件错误 {file_path}: {e}\")\n        return extracted_elements\n\n    try:\n        tree = ast.parse(source_code_full, filename=file_path)\n    except SyntaxError as e:\n        print(f\"  [!] 文件 {file_path} 中存在语法错误: {e}\")\n        return extracted_elements\n\n    for node in tree.body: # Iterate over top-level nodes in the module\n        current_class_name = None\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            # Top-level function\n            try:\n                element_code = ast.get_source_segment(source_code_full, node)\n                if element_code:\n                    extracted_elements.append({\n                        \"file_path\": file_path,\n                        \"name\": node.name,\n                        \"type\": \"async function\" if isinstance(node, ast.AsyncFunctionDef) else \"function\",\n                        \"code\": element_code,\n                        \"start_line\": node.lineno,\n                        \"end_line\": node.end_lineno,\n                        \"class_name\": None\n                    })\n            except Exception as e:\n                print(f\"  [!] 提取函数 '{node.name}' 代码时出错: {e}\")\n\n        elif isinstance(node, ast.ClassDef):\n            current_class_name = node.name\n            try:\n                class_code_segment = ast.get_source_segment(source_code_full, node)\n                if class_code_segment:\n                     extracted_elements.append({\n                        \"file_path\": file_path,\n                        \"name\": node.name,\n                        \"type\": \"class\",\n                        \"code\": class_code_segment, # Contains the full class code including methods\n                        \"start_line\": node.lineno,\n                        \"end_line\": node.end_lineno,\n                        \"class_name\": None\n                    })\n            except Exception as e:\n                print(f\"  [!] 提取类 '{node.name}' 定义代码时出错: {e}\")\n\n            for method_node in node.body:\n                if isinstance(method_node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    try:\n                        method_code = ast.get_source_segment(source_code_full, method_node)\n                        if method_code:\n                            extracted_elements.append({\n                                \"file_path\": file_path,\n                                \"name\": method_node.name,\n                                \"type\": \"async method\" if isinstance(method_node, ast.AsyncFunctionDef) else \"method\",\n                                \"code\": method_code,\n                                \"start_line\": method_node.lineno,\n                                \"end_line\": method_node.end_lineno,\n                                \"class_name\": current_class_name\n                            })\n                    except Exception as e:\n                        print(f\"  [!] 提取方法 '{method_node.name}' (类 {current_class_name}) 代码时出错: {e}\")\n    \n    if extracted_elements:\n        print(f\"  从 {os.path.basename(file_path)} 提取了 {len(extracted_elements)} 个元素。\")\n    return extracted_elements",
        "start_line": 60,
        "end_line": 143,
        "class_name": null,
        "explanation": "这个Python函数`extract_code_elements_from_file`的主要功能是从给定的Python文件中提取代码元素（函数、类和方法）的结构化信息。以下是详细说明：\n\n目的：\n- 解析Python源代码文件，提取其中的函数、类和方法等代码元素\n- 收集每个元素的元数据（如名称、类型、位置等）和实际源代码\n- 主要用于代码分析、文档生成或静态检查等场景\n\n输入：\n- `file_path`：字符串类型，表示要解析的Python文件的绝对路径\n\n输出：\n- 返回一个字典列表，每个字典代表一个代码元素，包含以下字段：\n  - `file_path`：源文件路径\n  - `name`：元素名称\n  - `type`：元素类型（\"function\"/\"async function\"/\"class\"/\"method\"/\"async method\"）\n  - `code`：元素的完整源代码\n  - `start_line`/`end_line`：元素在文件中的起止行号\n  - `class_name`：对于方法，记录所属类名；其他为None\n\n主要行为：\n1. 读取并解析指定Python文件\n2. 使用Python的`ast`模块构建抽象语法树(AST)\n3. 遍历AST节点，识别三种主要元素：\n   - 顶层函数（包括普通函数和异步函数）\n   - 类定义\n   - 类中的方法（包括普通方法和异步方法）\n4. 使用`ast.get_source_segment`获取每个元素的完整源代码\n5. 收集所有元素的元数据并返回\n6. 处理过程中会捕获并报告文件读取错误和语法错误\n\n注意事项：\n- 需要Python 3.8+（因为使用了`ast.get_source_segment`）\n- 会跳过有语法错误的文件\n- 对每个提取操作都有错误处理，不会因单个元素提取失败而中断整个流程\n- 输出中包含详细的代码位置信息，便于后续分析",
        "docstring": "def extract_code_elements_from_file(file_path: str) -> list[dict]:\n    \"\"\"Extracts code elements (functions, classes, methods) from a Python source file.\n    \n    Parses the given Python file using AST and extracts structural code elements including:\n    - Top-level functions (both sync and async)\n    - Class definitions (including their methods)\n    - Methods (both sync and async) with their containing class context\n\n    The extraction preserves source code segments with accurate line number information.\n\n    Args:\n        file_path: Absolute path to the Python source file to analyze. Must be UTF-8 encoded.\n\n    Returns:\n        List of dictionaries where each dictionary represents a code element with these keys:\n        - file_path: Source file path (same as input)\n        - name: Element name (function/class/method name)\n        - type: Element type ('function', 'async function', 'class', 'method', 'async method')\n        - code: Full source code of the element\n        - start_line: Starting line number in source file\n        - end_line: Ending line number in source file\n        - class_name: Containing class name for methods (None for top-level elements)\n\n    Note:\n        Requires Python 3.8+ for ast.get_source_segment() functionality.\n        Silently handles syntax errors and file access issues, returning empty list on failure.\n    \"\"\"\n    # [原有函数实现...]"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\deepseek_client.py",
        "name": "initialize_deepseek_client",
        "type": "function",
        "code": "def initialize_deepseek_client():  \n    \"\"\"  \n    初始化并返回DeepSeek API客户端。  \n    \"\"\"  \n    if not DEEPSEEK_API_KEY:  \n        raise ValueError(\"未在环境变量中找到DEEPSEEK_API_KEY。\"  \n                         \"请在.env文件或系统环境中设置。\")  \n\n    try:  \n        client = openai.OpenAI(  \n            api_key=DEEPSEEK_API_KEY,  \n            base_url=DEEPSEEK_BASE_URL  \n        )  \n        print(\"DeepSeek客户端初始化成功。\")  \n        # 可在此处添加简单测试调用（如列出模型，若支持）  \n        # 或低成本API调用来确保连接性。  \n        # 示例：尝试列出模型（实际端点可能不同或不支持）：  \n        # models = client.models.list()  \n        # print(\"可用模型（示例）:\", models.data[0].id if models.data else \"未找到模型\")  \n        return client  \n    except Exception as e:  \n        print(f\"初始化DeepSeek客户端时出错：{e}\")  \n        return None",
        "start_line": 18,
        "end_line": 40,
        "class_name": null,
        "explanation": "这个名为`initialize_deepseek_client`的Python函数用于初始化并返回一个DeepSeek API客户端。以下是详细解释：\n\n**目的**：\n- 创建一个配置好的DeepSeek API客户端实例，用于后续与DeepSeek API的交互\n\n**输入**：\n- 无显式参数输入\n- 但依赖两个全局/环境变量：\n  - `DEEPSEEK_API_KEY`：API密钥（必需）\n  - `DEEPSEEK_BASE_URL`：API基础URL\n\n**输出**：\n- 成功时：返回一个`openai.OpenAI`客户端实例\n- 失败时：返回`None`\n\n**主要行为**：\n1. **验证检查**：\n   - 首先检查`DEEPSEEK_API_KEY`是否存在，不存在则抛出`ValueError`异常\n\n2. **客户端初始化**：\n   - 使用提供的API密钥和基础URL创建OpenAI客户端实例\n\n3. **成功处理**：\n   - 打印成功消息\n   - 返回客户端实例（注释中提到了可选的测试调用，但当前代码中未实际执行）\n\n4. **错误处理**：\n   - 捕获可能出现的异常并打印错误信息\n   - 返回`None`表示初始化失败\n\n**典型使用场景**：\n```python\nclient = initialize_deepseek_client()\nif client:\n    # 使用client进行API调用\nelse:\n    # 处理初始化失败的情况\n```\n\n**注意事项**：\n- 函数假设相关配置已通过环境变量或其它方式设置\n- 包含注释掉的示例代码，展示了如何进行简单的连接测试（如列出可用模型）\n- 错误处理较为基础，实际应用中可能需要更细致的处理",
        "docstring": "def initialize_deepseek_client():\n    \"\"\"初始化并返回配置好的DeepSeek API客户端实例。\n\n    该函数会检查环境变量中的DEEPSEEK_API_KEY，若缺失则抛出异常。成功时返回\n    经认证的OpenAI客户端实例（适配DeepSeek服务端点），失败时返回None并打印错误。\n\n    Returns:\n        openai.OpenAI | None: 配置完成的客户端对象，包含以下预置参数：\n            - api_key: 从环境变量DEEPSEEK_API_KEY加载\n            - base_url: 使用模块级常量DEEPSEEK_BASE_URL\n        初始化失败时返回None\n\n    Raises:\n        ValueError: 当环境变量中未检测到DEEPSEEK_API_KEY时触发\n\n    Notes:\n        - 包含连接性测试注释（需取消注释示例代码）\n        - 错误处理会捕获所有异常类型并转换为None返回\n        - 初始化成功时会打印确认信息\n    \"\"\"\n    if not DEEPSEEK_API_KEY:\n        raise ValueError(\"未在环境变量中找到DEEPSEEK_API_KEY。\"\n                         \"请在.env文件或系统环境中设置。\")\n\n    try:\n        client = openai.OpenAI(\n            api_key=DEEPSEEK_API_KEY,\n            base_url=DEEPSEEK_BASE_URL\n        )\n        print(\"DeepSeek客户端初始化成功。\")\n        return client\n    except Exception as e:"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "_make_api_call",
        "type": "function",
        "code": "def _make_api_call(client: Any, messages: List[Dict[str, str]], max_tokens: int) -> Optional[str]:\n    \"\"\"\n    调用DeepSeek API的辅助函数\n    \"\"\"\n    try:\n        response = client.chat.completions.create(\n            model=DEEPSEEK_MODEL_NAME,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=TEMPERATURE\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"    [!] API调用错误: {e}\")\n        # 可添加更具体的错误处理（例如处理限流、认证错误等）\n        return None",
        "start_line": 14,
        "end_line": 29,
        "class_name": null,
        "explanation": "这个名为`_make_api_call`的Python函数是一个用于调用DeepSeek API的辅助函数。以下是它的详细说明：\n\n**目的**：\n- 封装与DeepSeek API的交互逻辑，简化API调用过程\n- 处理API调用中可能出现的错误\n\n**输入参数**：\n1. `client`: API客户端对象（类型为Any，表示可以是任何类型）\n2. `messages`: 消息列表，每个消息是一个字典，包含键值对（如角色和内容）\n3. `max_tokens`: 整数，指定API返回的最大token数量\n\n**输出**：\n- 成功时：返回API响应中第一个选择的消息内容（去除首尾空格后的字符串）\n- 失败时：打印错误信息并返回None\n\n**主要行为**：\n1. 使用提供的客户端、消息和参数调用DeepSeek API的聊天补全功能\n2. 使用预定义的模型名称(`DEEPSEEK_MODEL_NAME`)和温度参数(`TEMPERATURE`)\n3. 尝试从API响应中提取并返回第一个选择的消息内容\n4. 如果调用过程中出现任何异常，会捕获并打印错误信息，然后返回None\n\n**备注**：\n- 函数名以下划线开头表示它是内部使用的辅助函数\n- 当前错误处理较简单，注释提到未来可以添加更具体的错误处理逻辑（如限流、认证错误等）\n- 使用了类型提示来明确参数和返回值的类型",
        "docstring": "def _make_api_call(client: Any, messages: List[Dict[str, str]], max_tokens: int) -> Optional[str]:\n    \"\"\"调用DeepSeek API并返回生成的文本内容。\n\n    这是一个辅助函数，用于封装与DeepSeek API的交互逻辑。它会尝试创建聊天补全并返回响应内容，\n    如果发生错误则返回None并打印错误信息。\n\n    Args:\n        client: DeepSeek API客户端实例，用于发起请求。\n        messages: 消息列表，每个消息是一个包含'role'和'content'键的字典。\n        max_tokens: 生成内容的最大token数量限制。\n\n    Returns:\n        成功时返回API响应的文本内容(去除首尾空格)，失败时返回None。\n\n    Note:\n        当前错误处理较为基础，仅打印错误信息。可根据需要添加更具体的错误处理逻辑，\n        例如限流或认证错误的特殊处理。\n    \"\"\"\n    try:\n        response = client.chat.completions.create(\n            model=DEEPSEEK_MODEL_NAME,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=TEMPERATURE\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"    [!] API调用错误: {e}\")\n        # 可添加更具体的错误处理（例如处理限流、认证错误等）\n        return None"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "generate_explanation_for_element",
        "type": "function",
        "code": "def generate_explanation_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"\n    为给定的代码元素生成纯文本解释\n    \"\"\"\n    element_type = code_element['type']\n    element_name = code_element['name']\n    element_code = code_element['code']\n    class_name = code_element.get('class_name')\n\n    prompt_intro = f\"你是一位擅长代码分析和文档编写的专家AI助手。\"\n    \n    user_prompt = f\"解释以下名为'{element_name}'的Python {element_type}\"\n    if class_name:\n        user_prompt += f\"（属于'{class_name}'类）\"\n    user_prompt += f\"的功能。代码如下：\\n\\n```python\\n{element_code}\\n```\\n\\n\"\n    user_prompt += \"请用清晰简洁的语言进行解释。重点说明其目的、输入、输出（如果有）以及主要行为。\"\n\n    messages = [\n        {\"role\": \"system\", \"content\": prompt_intro},\n        {\"role\": \"user\", \"content\": user_prompt}\n    ]\n\n    print(f\"  -> 正在为{element_type} '{element_name}'生成解释...\")\n    explanation = _make_api_call(client, messages, MAX_TOKENS_EXPLANATION)\n    \n    if explanation:\n        print(f\"  <- 已收到'{element_name}'的解释。\")\n    else:\n        print(f\"  <!> 未能为'{element_name}'生成解释。\")\n    return explanation",
        "start_line": 31,
        "end_line": 60,
        "class_name": null,
        "explanation": "这个函数`generate_explanation_for_element`的主要功能是为给定的Python代码元素生成纯文本解释。以下是详细说明：\n\n目的：\n- 通过调用AI API（如OpenAI）为代码元素（如函数、类、方法等）生成自然语言解释\n- 帮助开发者或用户理解代码元素的功能和行为\n\n输入：\n1. `client` - 一个API客户端对象，用于与AI服务通信\n2. `code_element` - 包含代码元素信息的字典，包含：\n   - `type`：代码元素类型（如\"function\"、\"class\"等）\n   - `name`：元素名称\n   - `code`：实际的代码内容\n   - `class_name`（可选）：如果元素是类方法，所属的类名\n\n输出：\n- 返回一个字符串（`Optional[str]`），包含AI生成的代码解释\n- 如果生成失败则返回None\n\n主要行为：\n1. 从输入字典中提取代码元素信息（类型、名称、代码等）\n2. 构造系统提示和用户提示：\n   - 系统提示设定AI角色为代码分析专家\n   - 用户提示包含代码元素的具体信息和请求解释的指令\n3. 调用`_make_api_call`函数向AI服务发送请求\n4. 打印生成过程的日志信息\n5. 返回AI生成的解释文本或None（如果失败）\n\n特点：\n- 支持为类方法生成解释（会包含类名信息）\n- 生成的解释会重点关注代码的目的、输入输出和主要行为\n- 包含详细的日志输出，便于调试和跟踪生成过程",
        "docstring": "def generate_explanation_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"为给定的代码元素生成纯文本解释。\n\n    使用AI客户端为指定的代码元素生成自然语言解释。解释内容包括元素的目的、输入输出\n    以及主要行为。\n\n    Args:\n        client: 用于与AI服务通信的客户端对象\n        code_element: 包含代码元素信息的字典，必须包含以下键：\n            - type: 代码元素类型（如'function'、'class'等）\n            - name: 代码元素名称\n            - code: 代码内容\n            可选键：\n            - class_name: 如果元素属于某个类，指定类名\n\n    Returns:\n        生成的纯文本解释字符串，如果生成失败则返回None\n\n    Note:\n        该函数会打印生成过程的进度信息到控制台。\n    \"\"\"\n    ...  # 函数实现保持不变"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "generate_docstring_for_element",
        "type": "function",
        "code": "def generate_docstring_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"\n    为给定的代码元素生成Google风格的文档字符串\n    \"\"\"\n    element_type = code_element['type']\n    element_name = code_element['name']\n    element_code = code_element['code']\n    class_name = code_element.get('class_name')\n\n    prompt_intro = f\"你是一位擅长生成高质量代码文档的专家AI助手。\"\n    \n    user_prompt = f\"为以下名为'{element_name}'的Python {element_type}\"\n    if class_name:\n        user_prompt += f\"（来自'{class_name}'类）\"\n    user_prompt += f\"生成简洁的Google风格文档字符串。代码如下：\\n\\n```python\\n{element_code}\\n```\\n\\n\"\n    user_prompt += \"文档字符串应准确描述其用途、参数（如果有，包括可推断的类型）、\"\n    user_prompt += \"以及返回值（如果有，包括可推断的类型）。对于类，提供简要概述，\"\n    user_prompt += \"并在概述中提及关键属性或方法（如适用）。不要在文档字符串主体中包含函数/方法/类签名，只包含描述性文本。\"\n    user_prompt += \"确保文档字符串以简短的摘要行开头，后跟空行，然后根据需要添加更详细的说明。正确格式化以符合Python规范。\"\n\n    messages = [\n        {\"role\": \"system\", \"content\": prompt_intro},\n        {\"role\": \"user\", \"content\": user_prompt}\n    ]\n\n    print(f\"  -> 正在为{element_type} '{element_name}'生成文档字符串...\")\n    docstring = _make_api_call(client, messages, MAX_TOKENS_DOCSTRING)\n    \n    if docstring:\n        # 清理LLM可能生成的多余markdown ```python ``` 代码块标记\n        if docstring.startswith(\"```python\\n\"):\n            docstring = docstring.replace(\"```python\\n\", \"\", 1)\n            if docstring.endswith(\"\\n```\"):\n                docstring = docstring[:-len(\"\\n```\")]\n        if docstring.startswith(\"```\"):  # 通用的 ```\n            docstring = docstring.replace(\"```\", \"\", 1)\n            if docstring.endswith(\"```\"):\n                docstring = docstring[:-len(\"```\")]\n\n        # 移除LLM可能生成的多余的开头/结尾三引号\n        docstring = docstring.strip().strip('\"\"\"').strip(\"'''\").strip()\n        print(f\"  <- 已收到'{element_name}'的文档字符串。\")\n    else:\n        print(f\"  <!> 未能为'{element_name}'生成文档字符串。\")\n    return docstring",
        "start_line": 62,
        "end_line": 106,
        "class_name": null,
        "explanation": "这个函数`generate_docstring_for_element`的主要目的是为给定的Python代码元素自动生成符合Google风格规范的文档字符串(docstring)。\n\n**输入:**\n- `client`: 一个API客户端对象，用于与AI服务交互\n- `code_element`: 包含代码元素信息的字典，包含以下键:\n  - `type`: 代码元素类型(如函数、类、方法等)\n  - `name`: 代码元素名称\n  - `code`: 代码元素的实际代码内容\n  - `class_name`(可选): 如果元素是类方法，则包含所属类名\n\n**输出:**\n- 返回一个字符串，即生成的文档字符串；如果生成失败则返回None\n\n**主要行为:**\n1. 从输入字典中提取代码元素的基本信息(类型、名称、代码等)\n2. 构造一个详细的提示(prompt)，要求AI生成符合Google风格的文档字符串\n3. 通过API调用(`_make_api_call`)获取AI生成的文档字符串\n4. 对返回的文档字符串进行清理:\n   - 移除可能多余的markdown代码块标记(```python ```)\n   - 移除可能多余的三引号('''或\"\"\")\n5. 打印生成过程的日志信息\n6. 返回清理后的文档字符串\n\n**特点:**\n- 生成的文档字符串遵循Google风格规范\n- 会根据代码元素类型(函数、类、方法等)生成适当的文档内容\n- 对于类方法，会在文档中包含所属类信息\n- 包含错误处理和日志记录功能\n\n这个函数主要用于自动化代码文档生成，特别适合在需要为大量代码快速生成文档的场景中使用。",
        "docstring": "def generate_docstring_for_element(client: Any, code_element: Dict[str, Any]) -> Optional[str]:\n    \"\"\"为给定的代码元素生成符合Google风格的文档字符串。\n\n    使用AI助手为Python代码元素（函数、方法、类等）自动生成文档字符串。生成的文档字符串\n    遵循Google风格指南，包含必要的描述、参数和返回值信息。\n\n    Args:\n        client: 用于与AI API交互的客户端对象\n        code_element: 包含代码元素信息的字典，需包含以下键：\n            - type: 代码元素类型（如'function'、'class'等）\n            - name: 元素名称\n            - code: 元素源代码\n            - class_name: 可选，如果元素是类方法，则包含所属类名\n\n    Returns:\n        str: 生成的文档字符串（已清理格式），如果生成失败则返回None\n\n    Note:\n        生成的文档字符串会自动清理多余的代码块标记和三引号，确保可直接插入到源代码中。\n        处理过程会打印状态信息到控制台。"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "generate_project_overview",
        "type": "function",
        "code": "def generate_project_overview(client: Any, all_elements: List[Dict[str, Any]], project_name: str = \"本项目\") -> Optional[str]:\n    \"\"\"\n    为README文件生成项目的高层概述\n    \"\"\"\n    if not all_elements:\n        return \"未提供代码元素，无法生成概述。\"\n\n    summaries = []\n    for element in all_elements:\n        if element.get('explanation'):  # 使用之前生成的解释\n            summary = f\"- {element['type'].capitalize()} '{element['name']}': {element['explanation'][:150]}...\"  # 截断以保持简洁\n            if element.get('class_name'):\n                summary = f\"- {element['type'].capitalize()} '{element['name']}' (在'{element['class_name']}'类中): {element['explanation'][:150]}...\"\n            summaries.append(summary)\n        elif element['type'] == 'class':  # 如果没有解释，使用类名\n            summaries.append(f\"- 类 '{element['name']}'\")\n\n    if not summaries:\n        return \"没有可用的解释来生成概述。\"\n\n    prompt_intro = \"你是一个负责为README文件创建项目摘要的AI助手。\"\n    user_prompt = (\n        f\"根据以下来自'{project_name}'的代码元素摘要，\"\n        f\"生成适合项目README文件的简洁、高层概述（2-4段）。\"\n        f\"概述应描述项目的主要目的和可从这些元素推断出的关键功能。\\n\\n\"\n        f\"代码元素摘要:\\n\" + \"\\n\".join(summaries[:20]) +  # 限制输入大小\n        f\"\\n\\n专注于描述项目可能的连贯叙述。\"\n    )\n    \n    messages = [\n        {\"role\": \"system\", \"content\": prompt_intro},\n        {\"role\": \"user\", \"content\": user_prompt}\n    ]\n\n    print(f\"  -> 正在为'{project_name}'生成项目概述...\")\n    overview = _make_api_call(client, messages, max_tokens=600)\n    if overview:\n        print(f\"  <- 已收到项目概述。\")\n    else:\n        print(f\"  <!> 未能生成项目概述。\")\n    return overview",
        "start_line": 108,
        "end_line": 148,
        "class_name": null,
        "explanation": "这个函数`generate_project_overview`的主要功能是为项目生成一个高层概述，适合放在README文件中。以下是详细说明：\n\n**目的**：\n- 根据代码元素的摘要信息，自动生成项目的简要描述\n- 帮助创建项目文档中的\"概述\"部分，说明项目的主要目的和关键功能\n\n**输入**：\n1. `client`: 用于进行API调用的客户端对象\n2. `all_elements`: 包含代码元素信息的字典列表，每个字典包含：\n   - `type`: 元素类型（如'class'）\n   - `name`: 元素名称\n   - `explanation`: 元素的解释说明（可选）\n   - `class_name`: 所属类名（可选）\n3. `project_name`: 项目名称（默认为\"本项目\"）\n\n**输出**：\n- 返回一个字符串，包含生成的项目概述\n- 如果没有可用的信息，返回错误提示字符串\n\n**主要行为**：\n1. 首先检查输入是否为空，如果是则返回错误信息\n2. 遍历所有代码元素，为每个有解释的元素生成简要摘要：\n   - 格式化为列表项形式\n   - 包含元素类型、名称和截断的解释（前150个字符）\n   - 如果是类中的元素，还会包含所属类名\n3. 如果没有生成任何摘要，返回错误信息\n4. 构造提示信息，要求AI生成2-4段的项目概述\n5. 调用API生成概述文本\n6. 打印状态信息并返回结果\n\n**特点**：\n- 会限制输入的摘要数量（最多20个）以避免过长的提示\n- 生成的概述会专注于项目的整体叙述和关键功能\n- 包含详细的日志输出，便于调试",
        "docstring": "Generates a high-level project overview for a README file based on code elements.\n\nThis function takes a list of code elements with their explanations and generates\na concise project overview suitable for a README file. The overview describes\nthe project's main purpose and key functionality inferred from the provided elements.\n\nArgs:\n    client (Any): Client object for making API calls to generate the overview.\n    all_elements (List[Dict[str, Any]]): List of code element dictionaries containing:\n        - 'type': Element type (e.g., 'class', 'function')\n        - 'name': Element name\n        - 'explanation': Generated explanation of the element (optional)\n        - 'class_name': Containing class name if element is a method (optional)\n    project_name (str): Name of the project to reference in the overview. Defaults to \"本项目\".\n\nReturns:\n    Optional[str]: Generated project overview as markdown text, or None if generation fails.\n        Returns specific error messages if:\n        - No elements are provided (\"未提供代码元素，无法生成概述。\")\n        - No usable explanations are available (\"没有可用的解释来生成概述。\")\n\nThe function truncates long explanations (150 chars) and limits input to 20 elements\nto maintain conciseness. Uses an AI API call to synthesize the final overview."
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\doc_generator.py",
        "name": "process_elements_for_docs",
        "type": "function",
        "code": "def process_elements_for_docs(client: Any, code_elements: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"\n    遍历代码元素，为每个元素生成解释和文档字符串。\n    通过添加'explanation'和'docstring'键来修改输入的字典列表。\n    \"\"\"\n    print(f\"\\n开始为{len(code_elements)}个元素生成文档...\")\n    for i, element in enumerate(code_elements):\n        print(f\"\\n处理元素 {i+1}/{len(code_elements)}: {element['type']} '{element['name']}' 在 '{element['file_path']}'\")\n        \n        # 过滤掉可能不需要详细解释/文档字符串的元素（例如非常短的元素）\n        # 或基于类型过滤（例如，如果不想为类本身生成文档，只处理其方法）\n        # 目前，我们处理所有函数、方法和类。\n        if element['type'] in ['function', 'method', 'async function', 'async method', 'class']:\n            explanation = generate_explanation_for_element(client, element)\n            element['explanation'] = explanation\n            time.sleep(API_CALL_DELAY_SECONDS)  # 遵守API速率限制\n\n            docstring = generate_docstring_for_element(client, element)\n            element['docstring'] = docstring\n            time.sleep(API_CALL_DELAY_SECONDS)  # 遵守API速率限制\n        else:\n            element['explanation'] = None\n            element['docstring'] = None\n            print(f\"  跳过为元素类型 {element['type']} 生成文档\")\n            \n    return code_elements",
        "start_line": 150,
        "end_line": 175,
        "class_name": null,
        "explanation": "这个函数`process_elements_for_docs`的主要功能是为代码元素生成解释和文档字符串。以下是详细说明：\n\n**目的**：\n- 为代码中的函数、方法、类等元素生成自然语言解释和标准化的文档字符串\n- 主要用于自动化代码文档生成过程\n\n**输入**：\n- `client`: 一个客户端对象（类型未具体指定，可能是API客户端）\n- `code_elements`: 包含代码元素信息的字典列表，每个字典包含：\n  - `type`: 元素类型（如'function'、'method'、'class'等）\n  - `name`: 元素名称\n  - `file_path`: 所在文件路径\n\n**输出**：\n- 返回修改后的`code_elements`列表，其中每个元素字典新增了两个键：\n  - `explanation`: 元素的自然语言解释\n  - `docstring`: 元素的格式化文档字符串\n\n**主要行为**：\n1. 打印开始处理的日志信息\n2. 遍历所有代码元素：\n   - 打印当前处理进度\n   - 只处理特定类型的元素（函数、方法、异步函数、异步方法、类）\n   - 对于这些元素：\n     - 调用`generate_explanation_for_element`生成解释\n     - 添加解释到元素字典\n     - 调用`generate_docstring_for_element`生成文档字符串\n     - 添加文档字符串到元素字典\n     - 每次API调用后延迟（遵守速率限制）\n   - 对于其他类型元素，设置解释和文档字符串为None\n3. 返回处理后的元素列表\n\n**注意事项**：\n- 函数会跳过非函数/方法/类元素的文档生成\n- 包含API调用延迟机制（`API_CALL_DELAY_SECONDS`）以避免触发速率限制\n- 处理过程有详细的控制台日志输出",
        "docstring": "def process_elements_for_docs(client: Any, code_elements: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Processes code elements by generating explanations and docstrings for each.\n    \n    Iterates through a list of code elements and enhances each by adding 'explanation' and \n    'docstring' fields. Only processes functions, methods, and classes; skips other element types.\n    Respects API rate limits with built-in delays between requests.\n\n    Args:\n        client: Client object used to interact with the documentation generation API.\n        code_elements: List of dictionaries representing code elements to process. Each \n            dictionary should contain 'type', 'name', and 'file_path' keys at minimum.\n\n    Returns:\n        List[Dict[str, Any]]: The modified input list with added 'explanation' and 'docstring' \n            keys for each processed element. Unprocessed elements will have these keys set to None.\n\n    Note:\n        Currently processes these element types: function, method, async function, \n        async method, and class. All other types are skipped.\n    \"\"\"\n    ..."
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\main.py",
        "name": "sanitize_filename",
        "type": "function",
        "code": "def sanitize_filename(name_part: str) -> str:\n    \"\"\"\n    清理字符串，使其适合作为文件名的一部分。\n    移除或替换不安全/不合适的字符。\n    \"\"\"\n    if not name_part:\n        return \"\"\n    name_part = str(name_part) # 确保是字符串\n    # 替换路径分隔符，移除不期望的字符\n    name_part = name_part.replace(os.path.sep, '_')\n    # 只保留字母数字、空格、点、下划线、中横线\n    valid_chars = \"\".join(c for c in name_part if c.isalnum() or c in (' ', '.', '_', '-')).strip()\n    # 避免文件名过长，并替换空格为下划线\n    return valid_chars[:60].replace(' ', '_')",
        "start_line": 20,
        "end_line": 33,
        "class_name": null,
        "explanation": "这个名为 `sanitize_filename` 的Python函数用于清理字符串，使其适合作为文件名的一部分。以下是详细说明：\n\n**目的**：\n- 将任意输入字符串转换为安全的文件名（或文件名的一部分）\n- 移除或替换可能引起文件系统问题的特殊字符\n- 防止文件名过长\n\n**输入**：\n- `name_part: str`：需要清理的原始字符串（可以是任何类型，函数会强制转换为字符串）\n\n**输出**：\n- `str`：清理后的安全字符串\n\n**主要行为**：\n1. 空值处理：如果输入为空，直接返回空字符串\n2. 类型转换：确保输入被转换为字符串类型\n3. 路径分隔符替换：将操作系统路径分隔符（如/或\\）替换为下划线_\n4. 字符过滤：只保留以下字符：\n   - 字母数字字符（a-z, A-Z, 0-9）\n   - 空格、点（.）、下划线（_）、中横线（-）\n5. 空格处理：将所有空格替换为下划线\n6. 长度限制：截断字符串，使其不超过60个字符\n\n**示例**：\n输入：`\"My Document: 2023/04/01\"`\n输出：`\"My_Document_2023_04_01\"`（假设未超过60字符）\n\n注意：这个函数不保证输出字符串的唯一性，只是确保字符串适合作为文件名。",
        "docstring": "def sanitize_filename(name_part: str) -> str:\n    \"\"\"Cleans a string to make it suitable as a filename component.\n    \n    Removes or replaces unsafe/inappropriate characters from the input string to create a\n    valid filename. The resulting string contains only alphanumeric characters, spaces,\n    dots, underscores, and hyphens. Spaces are replaced with underscores, and the\n    length is limited to 60 characters.\n\n    Args:\n        name_part: Input string to be sanitized. Will be converted to string if not already.\n\n    Returns:\n        Sanitized string suitable for use as a filename component. Returns an empty string\n        if the input is empty or falsy.\n    \"\"\"\n    if not name_part:\n        return \"\"\n    name_part = str(name_part) # 确保是字符串\n    # 替换路径分隔符，移除不期望的字符\n    name_part = name_part.replace(os.path.sep, '_')\n    # 只保留字母数字、空格、点、下划线、中横线\n    valid_chars = \"\".join(c for c in name_part if c.isalnum() or c in (' ', '.', '_', '-')).strip()\n    # 避免文件名过长，并替换空格为下划线\n    return valid_chars[:60].replace(' ', '_')"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\script_generator.py",
        "name": "_make_llm_call_for_script",
        "type": "function",
        "code": "def _make_llm_call_for_script(client: Any, messages: List[Dict[str, str]], max_tokens: int) -> Optional[str]:\n    \"\"\"\n    辅助函数，用于为脚本生成调用 LLM API。\n    (与 doc_generator 中的 _make_api_call 类似，但可能使用不同模型或参数)\n    \"\"\"\n    try:\n        response = client.chat.completions.create(\n            model=DEEPSEEK_MODEL_SCRIPT_GENERATION,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=TEMPERATURE_SCRIPT\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"    [!] LLM API Call Error (for script): {e}\")\n        return None",
        "start_line": 19,
        "end_line": 34,
        "class_name": null,
        "explanation": "这个名为 `_make_llm_call_for_script` 的 Python 函数是一个辅助函数，专门用于调用大语言模型（LLM）API 来生成脚本内容。以下是它的详细说明：\n\n### 目的\n- 封装对大语言模型 API 的调用逻辑，用于脚本生成任务\n- 处理 API 调用过程中的异常情况\n- 返回模型生成的脚本内容或错误时返回 None\n\n### 输入参数\n1. `client`: 一个 API 客户端对象，用于实际发起 LLM 调用\n2. `messages`: 包含对话消息的字典列表，格式为 `List[Dict[str, str]]`，通常包含系统提示和用户输入\n3. `max_tokens`: 整数，限制模型生成的最大 token 数量\n\n### 输出\n- 成功时：返回模型生成的脚本内容字符串（经过去除首尾空格的清理）\n- 失败时：返回 `None` 并打印错误信息\n\n### 主要行为\n1. 使用指定的模型参数调用 LLM API：\n   - 使用预设的 `DEEPSEEK_MODEL_SCRIPT_GENERATION` 模型\n   - 传入对话消息 (`messages`)\n   - 设置最大 token 数 (`max_tokens`)\n   - 使用预设的温度参数 `TEMPERATURE_SCRIPT`（控制生成随机性）\n\n2. 处理响应：\n   - 从 API 响应中提取第一个选择的内容\n   - 去除内容首尾空格后返回\n\n3. 错误处理：\n   - 捕获所有异常并打印错误信息\n   - 返回 `None` 表示调用失败\n\n### 特点\n- 专为脚本生成任务设计（区别于文档生成）\n- 使用预设的模型和温度参数\n- 简单的错误处理机制",
        "docstring": "def _make_llm_call_for_script(client: Any, messages: List[Dict[str, str]], max_tokens: int) -> Optional[str]:\n    \"\"\"Makes an API call to an LLM for script generation purposes.\n    \n    This helper function is specifically designed for generating scripts by calling a language model API.\n    Similar to _make_api_call in doc_generator but may use different models or parameters.\n\n    Args:\n        client: The LLM client instance used to make the API call.\n        messages: List of message dictionaries containing 'role' and 'content' keys.\n        max_tokens: Maximum number of tokens to generate in the response.\n\n    Returns:\n        The generated script content as a string if successful, or None if an error occurs.\n\n    Note:\n        Uses predefined constants DEEPSEEK_MODEL_SCRIPT_GENERATION for the model and\n        TEMPERATURE_SCRIPT for temperature parameter.\n    \"\"\"\n    try:\n        response = client.chat.completions.create(\n            model=DEEPSEEK_MODEL_SCRIPT_GENERATION,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=TEMPERATURE_SCRIPT\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"    [!] LLM API Call Error (for script): {e}\")\n        return None"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\script_generator.py",
        "name": "generate_script_for_section",
        "type": "function",
        "code": "def generate_script_for_section(client: Any, section_data: Dict[str, Any], project_name: str, target_audience: str = \"初学者\") -> Optional[str]:\n    \"\"\"\n    为教程大纲中的单个部分生成脚本。\n    \"\"\"\n    section_type = section_data.get(\"section_type\")\n    title = section_data.get(\"title\")\n    script_prompt = \"\"\n    system_message = f\"你是一位经验丰富的技术教程编剧和内容创作者。你的任务是为编程教程视频撰写清晰、引人入胜且易于理解的旁白脚本。脚本应面向 {target_audience}。\"\n\n    print(f\"\\n  -> 正在为教程部分 '{title}' (类型: {section_type}) 生成脚本...\")\n\n    if section_type == \"introduction\":\n        project_overview = section_data.get(\"content_source\", f\"{project_name} 是一个非常有用的项目。\")\n        script_prompt = (\n            f\"为名为 '{project_name}' 的项目生成一段引人入胜的视频教程开场白。\\n\"\n            f\"项目概览：{project_overview}\\n\"\n            f\"脚本应包含：\\n\"\n            f\"1. 欢迎语。\\n\"\n            f\"2. 简要介绍项目是什么，解决了什么问题。\\n\"\n            f\"3. 预告通过本教程学习者能掌握什么。\\n\"\n            f\"4. 鼓励观众继续观看。\\n\"\n            f\"请加入视觉提示，例如：[显示项目Logo]、[展示项目运行效果的快速剪辑]、[显示教程标题卡]。\"\n        )\n    \n    elif section_type == \"setup\":\n        setup_instructions_placeholder = section_data.get(\"content_source\", \"请描述安装和配置步骤。\")\n        script_prompt = (\n            f\"为 '{project_name}' 项目的视频教程生成“环境设置与安装”部分的脚本。\\n\"\n            f\"基本要求：{setup_instructions_placeholder}\\n\"\n            f\"脚本应包含：\\n\"\n            f\"1. 需要安装哪些主要工具或库（例如，Python 版本、pip install ...）。\\n\"\n            f\"2. 如何进行基本的项目配置（例如，API密钥、环境变量等，如果适用）。\\n\"\n            f\"3. 一个简单的导入示例（如果适用）。\\n\"\n            f\"请加入视觉提示，例如：[显示命令行界面]、[高亮显示需要输入的命令]、[展示代码编辑器中的导入语句]。\"\n        )\n\n    elif section_type == \"core_feature_detail\":\n        element_name = section_data.get(\"element_name\")\n        element_type = section_data.get(\"element_type\")\n        class_name = section_data.get(\"element_class_name\")\n        code_snippet = section_data.get(\"code_snippet\", \"# 代码片段缺失\")\n        explanation = section_data.get(\"explanation\", \"这个功能非常重要。\") # 来自步骤3的解释\n\n        feature_name_for_prompt = f\"`{class_name}.{element_name}`\" if class_name else f\"`{element_name}`\"\n\n        script_prompt = (\n            f\"为名为 '{project_name}' 的项目的视频教程中关于核心功能 '{feature_name_for_prompt}' ({element_type}) 的部分生成详细讲解脚本。\\n\"\n            f\"这是该功能的代码：\\n```python\\n{code_snippet}\\n```\\n\"\n            f\"这是对该功能的文字解释（供你参考，请用更口语化和教学性的方式表达）：\\n\\\"{explanation}\\\"\\n\\n\"\n            f\"脚本应包含：\\n\"\n            f\"1. 清晰说明这个功能是做什么的，它的主要目的是什么。\\n\"\n            f\"2. （如果适用）对其重要参数进行解释。\\n\"\n            f\"3. （如果适用）解释它返回什么。\\n\"\n            f\"4. 如何在实际中使用它（可以虚构一个简单场景）。\\n\"\n            f\"5. 逐步引导观众理解代码逻辑，但避免逐行朗读代码，而是解释关键部分和整体流程。\\n\"\n            f\"请加入视觉提示，例如：[在屏幕上显示代码片段：{feature_name_for_prompt}]、[高亮代码的关键行]、[显示一个简单的调用示例]、[图示说明数据流或逻辑]。\"\n        )\n    \n    elif section_type == \"conclusion\":\n        conclusion_placeholder = section_data.get(\"content_source\", \"总结教程内容并鼓励学习。\")\n        script_prompt = (\n            f\"为名为 '{project_name}' 的项目的视频教程生成“总结与展望”部分的脚本。\\n\"\n            f\"基本要求：{conclusion_placeholder}\\n\"\n            f\"脚本应包含：\\n\"\n            f\"1. 简要回顾本教程涵盖的主要内容和学习重点。\\n\"\n            f\"2. 强调学习者通过本教程掌握的关键技能。\\n\"\n            f\"3. 鼓励学习者动手实践，并提供一些练习建议（如果可能）。\\n\"\n            f\"4. （可选）指出可以进一步学习的相关资源或项目的高级特性。\\n\"\n            f\"5. 感谢观看并引导观众进行互动（点赞、评论、订阅等）。\\n\"\n            f\"请加入视觉提示，例如：[显示教程重点回顾列表]、[显示项目GitHub链接或文档链接]、[显示结束卡片和社交媒体图标]。\"\n        )\n    \n    else: # 对于 core_features_parent 或其他未明确处理的类型\n        print(f\"  [!] 注意: 暂未为教程部分类型 '{section_type}' 定义特定的脚本生成逻辑。将尝试通用生成。\")\n        content_source = section_data.get(\"content_source\", title) # Fallback to title or other available info\n        script_prompt = (\n            f\"为视频教程中标题为 '{title}' 的部分生成脚本内容。\\n\"\n            f\"相关信息：{content_source}\\n\"\n            f\"请确保内容清晰、有条理，并加入适当的视觉提示，如 [显示相关图表] 或 [高亮关键信息]。\"\n        )\n\n\n    if not script_prompt:\n        print(f\"  [!] 未能为教程部分 '{title}' 构建有效的提示。\")\n        return None\n\n    messages = [\n        {\"role\": \"system\", \"content\": system_message},\n        {\"role\": \"user\", \"content\": script_prompt}\n    ]\n    \n    section_script = _make_llm_call_for_script(client, messages, MAX_TOKENS_SCRIPT_SECTION)\n    \n    if section_script:\n        print(f\"  <- 已收到教程部分 '{title}' 的脚本。\")\n    else:\n        print(f\"  <!> 未能为教程部分 '{title}' 生成脚本。\")\n    return section_script",
        "start_line": 36,
        "end_line": 133,
        "class_name": null,
        "explanation": "这个函数`generate_script_for_section`是一个用于为编程教程视频生成旁白脚本的工具。以下是其主要功能的简明解释：\n\n**目的**：\n- 根据教程大纲中的不同部分（如介绍、安装、核心功能讲解、总结等）自动生成对应的视频旁白脚本\n- 生成的脚本会包含教学内容、视觉提示和适合目标受众的语言风格\n\n**输入参数**：\n1. `client`：与AI语言模型交互的客户端对象\n2. `section_data`：包含教程部分信息的字典，包括：\n   - section_type（部分类型，如\"introduction\"）\n   - title（标题）\n   - content_source（内容来源/描述）\n   - 其他特定类型需要的字段（如代码片段、类名等）\n3. `project_name`：教程所属项目名称\n4. `target_audience`：目标受众级别（默认为\"初学者\"）\n\n**输出**：\n- 返回生成的脚本字符串（成功时）\n- 返回None（当无法构建有效提示时）\n\n**主要行为**：\n1. 根据`section_type`确定要生成哪种类型的脚本（介绍/安装/核心功能/总结等）\n2. 为每种类型构建特定的提示模板，包含：\n   - 教学目标\n   - 内容要点\n   - 视觉提示建议（如\"[显示命令行界面]\"）\n3. 对于未明确处理的类型，使用通用模板\n4. 通过`_make_llm_call_for_script`调用AI模型生成最终脚本\n5. 打印生成过程的日志信息\n\n**特点**：\n- 支持多种教程部分类型，每种类型有定制化的生成逻辑\n- 生成的脚本包含教学内容和视频制作提示\n- 可根据目标受众调整语言难度（如面向初学者）\n- 有完善的错误处理和日志记录\n\n这个函数本质上是一个脚本生成模板引擎，将结构化的教程内容转换为适合视频录制的自然语言脚本。",
        "docstring": "为教程大纲中的单个部分生成视频脚本。\n\n根据给定的部分类型和内容数据，生成适合视频教程的旁白脚本。脚本会针对不同部分类型（如介绍、设置、核心功能等）进行定制化生成，\n并包含视觉提示标记。\n\nArgs:\n    client (Any): 用于与LLM服务交互的客户端对象\n    section_data (Dict[str, Any]): 包含部分信息的字典，应包含:\n        - section_type: 部分类型（如\"introduction\"、\"setup\"等）\n        - title: 部分标题\n        - content_source: 部分内容源文本（可选）\n        - 其他类型特定字段（如代码片段、解释等）\n    project_name (str): 项目名称，用于脚本个性化\n    target_audience (str): 目标受众级别，默认为\"初学者\"\n\nReturns:\n    Optional[str]: 生成的脚本内容字符串，如果生成失败则返回None\n\nNote:\n    - 支持的部分类型包括：\"introduction\"、\"setup\"、\"core_feature_detail\"和\"conclusion\"\n    - 对于未明确处理的类型，会尝试通用生成\n    - 生成的脚本包含视觉提示标记（如[显示项目Logo]）"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\script_generator.py",
        "name": "generate_full_tutorial_script",
        "type": "function",
        "code": "def generate_full_tutorial_script(client: Any, tutorial_outline: List[Dict[str, Any]], project_name: str, target_audience: str = \"初学者\") -> List[Dict[str, Any]]:\n    \"\"\"\n    遍历教程大纲，为每个部分生成脚本，并组装成完整的教程脚本。\n    返回的列表每个元素包含该部分的标题、类型和生成的脚本。\n    \"\"\"\n    full_script_parts = []\n    print(f\"\\n开始为项目 '{project_name}' 生成完整教程脚本...\")\n\n    for section_data in tutorial_outline:\n        if section_data[\"section_type\"] == \"core_features_parent\":\n            # 对于父部分，我们可以选择生成一个过渡性的介绍\n            parent_title = section_data.get(\"title\")\n            # 或者直接处理其子部分\n            print(f\"\\n  处理核心功能组: '{parent_title}'...\")\n            for sub_section_data in section_data.get(\"sub_sections\", []):\n                script_content = generate_script_for_section(client, sub_section_data, project_name, target_audience)\n                full_script_parts.append({\n                    \"title\": sub_section_data.get(\"title\"),\n                    \"type\": sub_section_data.get(\"section_type\"),\n                    \"script\": script_content if script_content else \"# 未能生成此部分的脚本\"\n                })\n                time.sleep(API_CALL_DELAY_SECONDS) # API调用间的延迟\n        else:\n            script_content = generate_script_for_section(client, section_data, project_name, target_audience)\n            full_script_parts.append({\n                \"title\": section_data.get(\"title\"),\n                \"type\": section_data.get(\"section_type\"),\n                \"script\": script_content if script_content else \"# 未能生成此部分的脚本\"\n            })\n            time.sleep(API_CALL_DELAY_SECONDS) # API调用间的延迟\n            \n    print(f\"\\n完整教程脚本已生成 {len(full_script_parts)} 个部分。\")\n    return full_script_parts",
        "start_line": 136,
        "end_line": 168,
        "class_name": null,
        "explanation": "这个函数`generate_full_tutorial_script`的主要功能是根据教程大纲生成完整的教程脚本内容。以下是详细说明：\n\n目的：\n- 将教程大纲中的每个部分转换为实际的脚本内容\n- 适用于为特定项目创建面向初学者的教程\n\n输入参数：\n1. `client`：一个客户端对象（类型未具体指定，可能是API客户端）\n2. `tutorial_outline`：教程大纲，是字典列表，每个字典包含章节信息\n3. `project_name`：项目名称字符串\n4. `target_audience`：目标受众（默认为\"初学者\"）\n\n输出：\n- 返回字典列表，每个字典包含：\n  - `title`：章节标题\n  - `type`：章节类型\n  - `script`：生成的脚本内容（生成失败时返回占位文本）\n\n主要行为：\n1. 遍历教程大纲中的每个章节\n2. 对两种章节类型做不同处理：\n   - 如果是\"core_features_parent\"类型（核心功能父章节）：\n     * 处理其所有子章节\n     * 为每个子章节调用`generate_script_for_section`生成脚本\n   - 其他类型章节：\n     * 直接调用`generate_script_for_section`生成脚本\n3. 每次API调用后添加延迟（`API_CALL_DELAY_SECONDS`）\n4. 收集所有生成的脚本内容并返回\n\n其他特点：\n- 包含进度打印信息（开始/结束提示和处理进度）\n- 对生成失败的情况有容错处理（使用占位文本）\n- 保持API调用的合理间隔防止过载",
        "docstring": "def generate_full_tutorial_script(client: Any, tutorial_outline: List[Dict[str, Any]], project_name: str, target_audience: str = \"初学者\") -> List[Dict[str, Any]]:\n    \"\"\"为给定的教程大纲生成完整的教程脚本内容。\n\n    遍历教程大纲的每个部分，调用脚本生成函数，并组装成完整的教程脚本列表。支持处理核心功能组（父部分）及其子部分。\n\n    Args:\n        client: 用于生成脚本的客户端对象，类型由具体实现决定。\n        tutorial_outline: 教程大纲列表，每个元素为包含标题、类型和子部分（可选）的字典。\n        project_name: 项目名称，用于生成过程中的日志和脚本内容。\n        target_audience: 目标受众级别，默认为\"初学者\"。\n\n    Returns:\n        生成的完整教程脚本列表，每个元素包含标题、类型和脚本内容。若生成失败，脚本内容会包含占位文本。\n\n    Note:\n        在API调用之间会添加延迟（API_CALL_DELAY_SECONDS）以避免速率限制。"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\tutorial_planner.py",
        "name": "load_documentation_data",
        "type": "function",
        "code": "def load_documentation_data(output_base_dir: str, project_name: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    从指定的JSON文件加载文档化元素数据。\n\n    Args:\n        output_base_dir (str): 存放生成的JSON文件的基础目录 (例如 \"output_generated_docs\")。\n        project_name (str): 项目名称，用于构造JSON文件名。\n\n    Returns:\n        List[Dict[str, Any]]: 加载的文档化元素列表，如果失败则为空列表。\n    \"\"\"\n    json_input_filename = f\"{project_name}_documentation_data.json\"\n    # 注意：这里的 output_base_dir 是相对于当前工作目录的，\n    # 如果 tutorial_planner.py 被 main.py 调用，那么 os.getcwd() 通常是项目根目录。\n    json_input_path = os.path.join(output_base_dir, json_input_filename)\n\n    loaded_elements: List[Dict[str, Any]] = []\n    if os.path.exists(json_input_path):\n        try:\n            with open(json_input_path, 'r', encoding='utf-8') as f:\n                loaded_elements = json.load(f)\n            print(f\"[Tutorial Planner] 成功从 {json_input_path} 加载了 {len(loaded_elements)} 个文档化元素。\")\n        except Exception as e:\n            print(f\"[Tutorial Planner] 从 {json_input_path} 加载数据失败: {e}\")\n    else:\n        print(f\"[Tutorial Planner] 未找到已保存的 JSON 数据文件: {json_input_path}。\")\n    \n    return loaded_elements",
        "start_line": 6,
        "end_line": 33,
        "class_name": null,
        "explanation": "这个函数`load_documentation_data`的功能是从JSON文件中加载文档化元素数据。以下是详细说明：\n\n**目的**：\n- 从指定路径的JSON文件中读取并返回之前保存的文档化元素数据\n- 主要用于恢复/加载之前生成的文档数据，避免重复生成\n\n**输入参数**：\n1. `output_base_dir` (str): 存放JSON文件的基础目录路径\n2. `project_name` (str): 项目名称，用于自动构造JSON文件名\n\n**输出**：\n- 返回一个包含文档化元素的字典列表(`List[Dict[str, Any]]`)\n- 如果加载失败或文件不存在，则返回空列表\n\n**主要行为**：\n1. 根据项目名称和基础目录构造完整的JSON文件路径\n2. 检查目标JSON文件是否存在：\n   - 如果存在：尝试读取并解析JSON内容\n   - 如果不存在：打印提示信息并返回空列表\n3. 处理过程中会打印状态信息（成功/失败提示）\n4. 最终返回加载的数据或空列表\n\n**异常处理**：\n- 捕获并处理所有可能的读取/解析异常，避免程序崩溃\n- 遇到错误时会打印错误信息并返回空列表\n\n这个函数主要用于数据持久化和恢复，是文档生成流程中的一个辅助功能。",
        "docstring": "def load_documentation_data(output_base_dir: str, project_name: str) -> List[Dict[str, Any]]:\n    \"\"\"从项目输出目录加载文档化元素的JSON数据文件。\n\n    从指定的基础目录中加载以项目名称命名的JSON文件，该文件应包含文档化元素的数据。\n    如果文件不存在或加载失败，将返回空列表并打印错误信息。\n\n    Args:\n        output_base_dir: 存放生成的JSON文件的基础目录路径（相对于当前工作目录）\n        project_name: 项目名称，用于构造JSON文件名（格式为\"{project_name}_documentation_data.json\"）\n\n    Returns:\n        包含所有文档化元素的字典列表，每个元素表示为键值对字典。如果加载失败则返回空列表。\n\n    Note:\n        文件路径构造为 os.path.join(output_base_dir, f\"{project_name}_documentation_data.json\")\n        加载失败时会打印错误信息，但不会抛出异常"
    },
    {
        "file_path": "D:\\code_doc_generator\\src\\tutorial_planner.py",
        "name": "build_tutorial_outline",
        "type": "function",
        "code": "def build_tutorial_outline(documented_elements: List[Dict[str, Any]], \n                           project_name: str, \n                           readme_overview: Optional[str] = None) -> List[Dict[str, Any]]:\n    \"\"\"\n    根据文档化元素和项目信息构建教程大纲。\n\n    Args:\n        documented_elements (List[Dict[str, Any]]): 从JSON加载的文档化元素列表。\n        project_name (str): 项目名称。\n        readme_overview (Optional[str]): 从步骤三生成的项目概览文本。\n\n    Returns:\n        List[Dict[str, Any]]: 表示教程大纲的列表。\n    \"\"\"\n    if not documented_elements:\n        print(\"[Tutorial Planner] 没有可用于构建教程大纲的文档化元素。\")\n        return []\n\n    tutorial_outline: List[Dict[str, Any]] = []\n\n    # A. 引言\n    tutorial_outline.append({\n        \"section_type\": \"introduction\",\n        \"title\": f\"欢迎学习 {project_name} 教程\",\n        \"content_source\": readme_overview if readme_overview else f\"请基于 {project_name} 项目的目的和主要功能生成引言。\",\n        \"project_name\": project_name\n    })\n\n    # B. 环境设置\n    tutorial_outline.append({\n        \"section_type\": \"setup\",\n        \"title\": \"环境设置与安装\",\n        \"content_source\": f\"请提供关于如何安装和配置 {project_name} 项目的说明。\"\n    })\n\n    # C. 核心功能讲解\n    core_features_section = {\n        \"section_type\": \"core_features_parent\",\n        \"title\": \"核心功能详解\",\n        \"sub_sections\": []\n    }\n\n    elements_to_explain = sorted(\n        [el for el in documented_elements if el.get('explanation') and el['type'] in ['function', 'method', 'class', 'async function', 'async method']],\n        key=lambda x: (\n            x.get('file_path', ''),        # 使用 .get 提供默认值以增加稳健性\n            x.get('class_name') or '',     # 如果 class_name 是 None，则使用空字符串 '' 进行排序\n            x.get('start_line', 0)         # 使用 .get 提供默认值\n        )\n    )\n\n    for element in elements_to_explain:\n        feature_title = f\"{element['type'].capitalize()}：`{element['name']}`\"\n        if element.get('class_name'):\n            feature_title = f\"{element['type'].capitalize()}：`{element['class_name']}.{element['name']}`\"\n        \n        core_features_section[\"sub_sections\"].append({\n            \"section_type\": \"core_feature_detail\",\n            \"title\": feature_title,\n            \"element_name\": element['name'],\n            \"element_type\": element['type'],\n            \"element_class_name\": element.get('class_name'),\n            \"code_snippet\": element['code'],\n            \"explanation\": element['explanation'],\n            \"file_path\": element['file_path']\n        })\n    \n    if core_features_section[\"sub_sections\"]:\n        tutorial_outline.append(core_features_section)\n\n    # E. 总结与后续\n    tutorial_outline.append({\n        \"section_type\": \"conclusion\",\n        \"title\": \"总结与展望\",\n        \"content_source\": f\"请对 {project_name} 教程内容进行总结，并提供学习建议或下一步指引。\"\n    })\n    \n    print(f\"[Tutorial Planner] 教程大纲初步构建完成，包含 {len(tutorial_outline)} 个主要部分。\")\n    return tutorial_outline",
        "start_line": 35,
        "end_line": 113,
        "class_name": null,
        "explanation": "这个函数`build_tutorial_outline`的主要功能是根据项目的文档化元素和项目信息，自动构建一个教程大纲。以下是详细说明：\n\n### 目的\n- 为给定的项目创建一个结构化的教程大纲，便于后续生成完整的教程内容\n- 将代码文档元素组织成逻辑分明的教学章节\n\n### 输入\n1. `documented_elements`: 文档化元素列表（包含函数、方法、类等代码元素的文档信息）\n2. `project_name`: 项目名称（用于个性化教程标题）\n3. `readme_overview`: 可选的README概览文本（用作教程引言部分的内容来源）\n\n### 输出\n- 返回一个字典列表，每个字典表示教程的一个章节，包含：\n  - 章节类型(section_type)\n  - 标题(title)\n  - 内容来源(content_source)或子章节(sub_sections)\n\n### 主要行为\n1. **检查输入**：如果没有文档化元素，返回空列表\n2. **构建大纲结构**：\n   - 添加**引言**部分（使用README概览或生成提示）\n   - 添加**环境设置**部分（提供安装配置说明提示）\n3. **处理核心功能**：\n   - 筛选出需要讲解的代码元素（函数、方法、类等）\n   - 按文件路径、类名和起始行号排序\n   - 为每个元素创建详细子章节，包含代码片段和解释\n4. **添加总结**部分\n5. 打印构建完成信息并返回大纲\n\n### 大纲结构示例\n1. 引言（欢迎部分）\n2. 环境设置（安装指南）\n3. 核心功能详解（包含多个子章节）\n4. 总结与展望\n\n这个函数特别适合用于自动化文档生成工具，能够将代码文档转化为适合教学的教程结构。",
        "docstring": "def build_tutorial_outline(documented_elements: List[Dict[str, Any]], \n                         project_name: str, \n                         readme_overview: Optional[str] = None) -> List[Dict[str, Any]]:\n    \"\"\"根据项目文档元素构建结构化的教程大纲。\n    \n    该函数接收项目文档元素列表和项目信息，生成包含引言、环境设置、核心功能详解和总结等\n    标准章节的教程大纲结构。大纲采用分层结构组织，特别对代码元素进行排序和分组处理。\n\n    Args:\n        documented_elements: 从项目代码中提取的文档化元素列表，每个元素应包含类型、名称、\n            代码片段和解释说明等元数据\n        project_name: 用于个性化教程标题和内容提示的项目名称\n        readme_overview: 可选的README概览内容，用于生成教程引言部分\n\n    Returns:\n        结构化的教程大纲列表，每个条目代表一个章节，包含章节类型、标题和内容来源等信息。\n        核心功能章节会包含排序后的子章节列表。\n\n    Notes:\n        - 会自动过滤掉没有解释说明的代码元素\n        - 元素按文件路径、类名和起始行号排序\n        - 空输入将返回空列表并打印警告"
    }
]